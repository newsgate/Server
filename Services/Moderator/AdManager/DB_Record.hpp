/*
 * product   : NewsGate - news search WEB server
 * copyright : Copyright (c) 2005-2016 Karen Arutyunov
 * licenses  : CC BY-NC-SA 3.0; see accompanying LICENSE file
 *             Commercial; contact karen.arutyunov@gmail.com
 */

// Copyright (C) 2005-2008 Karen Arutyunov
//
// This program was generated by MySQL Class Generating Compiler
// MySQLClassGen (TM)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA

#ifndef _NEWSGATE_MODERATION_AD_DB_GLOBAL__400539675_
#define _NEWSGATE_MODERATION_AD_DB_GLOBAL__400539675_

#include <limits.h>

#include <string>
#include <sstream>

#include <El/Exception.hpp>
#include <El/MySQL/DB.hpp>

namespace NewsGate
{
  namespace Moderation
  {
    namespace Ad
    {
      namespace DB
      {
//
// Global class declaration
//
        class Global: public El::MySQL::Row
        {
        public:
          EL_EXCEPTION(Exception, El::MySQL::Exception);
          EL_EXCEPTION(IsNull, Exception);

        public:
          Global(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
            throw(Exception, El::Exception);

          El::MySQL::String selector_status() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong adv_max_ads_per_page() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLongLong update_num() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong pcws_weight_zones() const
           throw(Exception, El::Exception);

          El::MySQL::Double pcws_reduction_rate() const
           throw(Exception, El::Exception);

        };

//
// Global class definition
//
        inline
        Global::Global(El::MySQL::Result* result, unsigned long use_columns)
          throw(Exception, El::Exception)
            : Row(result)
        {
          unsigned long num_columns = std::min(use_columns, (unsigned long)5);

          if(result->num_fields() != num_columns)
          {
            std::ostringstream ostr;
            ostr << "Global::Global: unexpected number of fields "
                 << result->num_fields() << " instead of " << num_columns;

            throw Exception(ostr.str());
          }

          if(use_columns >= 0)
          {
            return;
          }

          enum_field_types type = (*result)[0].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Global::Global: unexpected type " << type
                 << " instead of 254 for field selector_status";

            throw Exception(ostr.str());
          }

          unsigned int flags = 
            (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Global::Global: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field selector_status";

            throw Exception(ostr.str());
          }

          const char* name = (*result)[0].name;

          if(strcmp(name, "selector_status"))
          {
            std::ostringstream ostr;
            ostr << "Global::Global: unexpected name " << name
                 << " instead of selector_status for field selector_status";

            throw Exception(ostr.str());
          }

          if(use_columns >= 1)
          {
            return;
          }

          type = (*result)[1].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Global::Global: unexpected type " << type
                 << " instead of 3 for field adv_max_ads_per_page";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Global::Global: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field adv_max_ads_per_page";

            throw Exception(ostr.str());
          }

          name = (*result)[1].name;

          if(strcmp(name, "adv_max_ads_per_page"))
          {
            std::ostringstream ostr;
            ostr << "Global::Global: unexpected name " << name
                 << " instead of adv_max_ads_per_page for field adv_max_ads_per_page";

            throw Exception(ostr.str());
          }

          if(use_columns >= 2)
          {
            return;
          }

          type = (*result)[2].type;

          if(type != 8)
          {
            std::ostringstream ostr;
            ostr << "Global::Global: unexpected type " << type
                 << " instead of 8 for field update_num";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Global::Global: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field update_num";

            throw Exception(ostr.str());
          }

          name = (*result)[2].name;

          if(strcmp(name, "update_num"))
          {
            std::ostringstream ostr;
            ostr << "Global::Global: unexpected name " << name
                 << " instead of update_num for field update_num";

            throw Exception(ostr.str());
          }

          if(use_columns >= 3)
          {
            return;
          }

          type = (*result)[3].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Global::Global: unexpected type " << type
                 << " instead of 3 for field pcws_weight_zones";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[3].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Global::Global: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field pcws_weight_zones";

            throw Exception(ostr.str());
          }

          name = (*result)[3].name;

          if(strcmp(name, "pcws_weight_zones"))
          {
            std::ostringstream ostr;
            ostr << "Global::Global: unexpected name " << name
                 << " instead of pcws_weight_zones for field pcws_weight_zones";

            throw Exception(ostr.str());
          }

          if(use_columns >= 4)
          {
            return;
          }

          type = (*result)[4].type;

          if(type != 5)
          {
            std::ostringstream ostr;
            ostr << "Global::Global: unexpected type " << type
                 << " instead of 5 for field pcws_reduction_rate";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[4].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Global::Global: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field pcws_reduction_rate";

            throw Exception(ostr.str());
          }

          name = (*result)[4].name;

          if(strcmp(name, "pcws_reduction_rate"))
          {
            std::ostringstream ostr;
            ostr << "Global::Global: unexpected name " << name
                 << " instead of pcws_reduction_rate for field pcws_reduction_rate";

            throw Exception(ostr.str());
          }

        }

        inline
        El::MySQL::String
        Global::selector_status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Global::selector_status: row_ is 0");
          }

          if(0 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Global::selector_status: unexpected index 0 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[0] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[0], lengths[0]);

          return tmp;
        }

        inline
        El::MySQL::UnsignedLong
        Global::adv_max_ads_per_page() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Global::adv_max_ads_per_page: row_ is 0");
          }

          if(1 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Global::adv_max_ads_per_page: unexpected index 1 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[1] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[1], lengths[1]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Global::adv_max_ads_per_page: failed to convert 'adv_max_ads_per_page' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::UnsignedLongLong
        Global::update_num() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Global::update_num: row_ is 0");
          }

          if(2 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Global::update_num: unexpected index 2 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long long value = 0;
          bool is_null = row_[2] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[2], lengths[2]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Global::update_num: failed to convert 'update_num' field data"
                " to unsigned long long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLongLong(is_null, value);
        }

        inline
        El::MySQL::UnsignedLong
        Global::pcws_weight_zones() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Global::pcws_weight_zones: row_ is 0");
          }

          if(3 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Global::pcws_weight_zones: unexpected index 3 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[3] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[3], lengths[3]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Global::pcws_weight_zones: failed to convert 'pcws_weight_zones' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::Double
        Global::pcws_reduction_rate() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Global::pcws_reduction_rate: row_ is 0");
          }

          if(4 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Global::pcws_reduction_rate: unexpected index 4 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          double value = 0;
          bool is_null = row_[4] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[4], lengths[4]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Global::pcws_reduction_rate: failed to convert 'pcws_reduction_rate' field data"
                " to double";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::Double(is_null, value);
        }

      }
    }
  }
}

namespace NewsGate
{
  namespace Moderation
  {
    namespace Ad
    {
      namespace DB
      {
//
// Page class declaration
//
        class Page: public El::MySQL::Row
        {
        public:
          EL_EXCEPTION(Exception, El::MySQL::Exception);
          EL_EXCEPTION(IsNull, Exception);

        public:
          Page(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
            throw(Exception, El::Exception);

          El::MySQL::UnsignedLong id() const
           throw(Exception, El::Exception);

          El::MySQL::String name() const
           throw(Exception, El::Exception);

          El::MySQL::String status() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong max_ad_num() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong advertiser_max_ad_num() const
           throw(Exception, El::Exception);

        };

//
// Page class definition
//
        inline
        Page::Page(El::MySQL::Result* result, unsigned long use_columns)
          throw(Exception, El::Exception)
            : Row(result)
        {
          unsigned long num_columns = std::min(use_columns, (unsigned long)5);

          if(result->num_fields() != num_columns)
          {
            std::ostringstream ostr;
            ostr << "Page::Page: unexpected number of fields "
                 << result->num_fields() << " instead of " << num_columns;

            throw Exception(ostr.str());
          }

          if(use_columns >= 0)
          {
            return;
          }

          enum_field_types type = (*result)[0].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Page::Page: unexpected type " << type
                 << " instead of 3 for field id";

            throw Exception(ostr.str());
          }

          unsigned int flags = 
            (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Page::Page: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field id";

            throw Exception(ostr.str());
          }

          const char* name = (*result)[0].name;

          if(strcmp(name, "id"))
          {
            std::ostringstream ostr;
            ostr << "Page::Page: unexpected name " << name
                 << " instead of id for field id";

            throw Exception(ostr.str());
          }

          if(use_columns >= 1)
          {
            return;
          }

          type = (*result)[1].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Page::Page: unexpected type " << type
                 << " instead of 254 for field name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Page::Page: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field name";

            throw Exception(ostr.str());
          }

          name = (*result)[1].name;

          if(strcmp(name, "name"))
          {
            std::ostringstream ostr;
            ostr << "Page::Page: unexpected name " << name
                 << " instead of name for field name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 2)
          {
            return;
          }

          type = (*result)[2].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Page::Page: unexpected type " << type
                 << " instead of 254 for field status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Page::Page: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field status";

            throw Exception(ostr.str());
          }

          name = (*result)[2].name;

          if(strcmp(name, "status"))
          {
            std::ostringstream ostr;
            ostr << "Page::Page: unexpected name " << name
                 << " instead of status for field status";

            throw Exception(ostr.str());
          }

          if(use_columns >= 3)
          {
            return;
          }

          type = (*result)[3].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Page::Page: unexpected type " << type
                 << " instead of 3 for field max_ad_num";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[3].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Page::Page: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field max_ad_num";

            throw Exception(ostr.str());
          }

          name = (*result)[3].name;

          if(strcmp(name, "max_ad_num"))
          {
            std::ostringstream ostr;
            ostr << "Page::Page: unexpected name " << name
                 << " instead of max_ad_num for field max_ad_num";

            throw Exception(ostr.str());
          }

          if(use_columns >= 4)
          {
            return;
          }

          type = (*result)[4].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Page::Page: unexpected type " << type
                 << " instead of 3 for field advertiser_max_ad_num";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[4].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x20)
          {
            std::ostringstream ostr;
            ostr << "Page::Page: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x20 for field advertiser_max_ad_num";

            throw Exception(ostr.str());
          }

          name = (*result)[4].name;

          if(strcmp(name, "advertiser_max_ad_num"))
          {
            std::ostringstream ostr;
            ostr << "Page::Page: unexpected name " << name
                 << " instead of advertiser_max_ad_num for field advertiser_max_ad_num";

            throw Exception(ostr.str());
          }

        }

        inline
        El::MySQL::UnsignedLong
        Page::id() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Page::id: row_ is 0");
          }

          if(0 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Page::id: unexpected index 0 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[0] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[0], lengths[0]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Page::id: failed to convert 'id' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::String
        Page::name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Page::name: row_ is 0");
          }

          if(1 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Page::name: unexpected index 1 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[1] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[1], lengths[1]);

          return tmp;
        }

        inline
        El::MySQL::String
        Page::status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Page::status: row_ is 0");
          }

          if(2 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Page::status: unexpected index 2 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[2] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[2], lengths[2]);

          return tmp;
        }

        inline
        El::MySQL::UnsignedLong
        Page::max_ad_num() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Page::max_ad_num: row_ is 0");
          }

          if(3 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Page::max_ad_num: unexpected index 3 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[3] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[3], lengths[3]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Page::max_ad_num: failed to convert 'max_ad_num' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::UnsignedLong
        Page::advertiser_max_ad_num() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Page::advertiser_max_ad_num: row_ is 0");
          }

          if(4 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Page::advertiser_max_ad_num: unexpected index 4 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[4] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[4], lengths[4]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Page::advertiser_max_ad_num: failed to convert 'advertiser_max_ad_num' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

      }
    }
  }
}

namespace NewsGate
{
  namespace Moderation
  {
    namespace Ad
    {
      namespace DB
      {
//
// Slot class declaration
//
        class Slot: public El::MySQL::Row
        {
        public:
          EL_EXCEPTION(Exception, El::MySQL::Exception);
          EL_EXCEPTION(IsNull, Exception);

        public:
          Slot(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
            throw(Exception, El::Exception);

          El::MySQL::UnsignedLong id() const
           throw(Exception, El::Exception);

          El::MySQL::String name() const
           throw(Exception, El::Exception);

          El::MySQL::String status() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong min_width() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong max_width() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong min_height() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong max_height() const
           throw(Exception, El::Exception);

        };

//
// Slot class definition
//
        inline
        Slot::Slot(El::MySQL::Result* result, unsigned long use_columns)
          throw(Exception, El::Exception)
            : Row(result)
        {
          unsigned long num_columns = std::min(use_columns, (unsigned long)7);

          if(result->num_fields() != num_columns)
          {
            std::ostringstream ostr;
            ostr << "Slot::Slot: unexpected number of fields "
                 << result->num_fields() << " instead of " << num_columns;

            throw Exception(ostr.str());
          }

          if(use_columns >= 0)
          {
            return;
          }

          enum_field_types type = (*result)[0].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Slot::Slot: unexpected type " << type
                 << " instead of 3 for field id";

            throw Exception(ostr.str());
          }

          unsigned int flags = 
            (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Slot::Slot: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field id";

            throw Exception(ostr.str());
          }

          const char* name = (*result)[0].name;

          if(strcmp(name, "id"))
          {
            std::ostringstream ostr;
            ostr << "Slot::Slot: unexpected name " << name
                 << " instead of id for field id";

            throw Exception(ostr.str());
          }

          if(use_columns >= 1)
          {
            return;
          }

          type = (*result)[1].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Slot::Slot: unexpected type " << type
                 << " instead of 254 for field name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Slot::Slot: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field name";

            throw Exception(ostr.str());
          }

          name = (*result)[1].name;

          if(strcmp(name, "name"))
          {
            std::ostringstream ostr;
            ostr << "Slot::Slot: unexpected name " << name
                 << " instead of name for field name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 2)
          {
            return;
          }

          type = (*result)[2].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Slot::Slot: unexpected type " << type
                 << " instead of 254 for field status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Slot::Slot: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field status";

            throw Exception(ostr.str());
          }

          name = (*result)[2].name;

          if(strcmp(name, "status"))
          {
            std::ostringstream ostr;
            ostr << "Slot::Slot: unexpected name " << name
                 << " instead of status for field status";

            throw Exception(ostr.str());
          }

          if(use_columns >= 3)
          {
            return;
          }

          type = (*result)[3].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Slot::Slot: unexpected type " << type
                 << " instead of 3 for field min_width";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[3].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Slot::Slot: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field min_width";

            throw Exception(ostr.str());
          }

          name = (*result)[3].name;

          if(strcmp(name, "min_width"))
          {
            std::ostringstream ostr;
            ostr << "Slot::Slot: unexpected name " << name
                 << " instead of min_width for field min_width";

            throw Exception(ostr.str());
          }

          if(use_columns >= 4)
          {
            return;
          }

          type = (*result)[4].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Slot::Slot: unexpected type " << type
                 << " instead of 3 for field max_width";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[4].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Slot::Slot: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field max_width";

            throw Exception(ostr.str());
          }

          name = (*result)[4].name;

          if(strcmp(name, "max_width"))
          {
            std::ostringstream ostr;
            ostr << "Slot::Slot: unexpected name " << name
                 << " instead of max_width for field max_width";

            throw Exception(ostr.str());
          }

          if(use_columns >= 5)
          {
            return;
          }

          type = (*result)[5].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Slot::Slot: unexpected type " << type
                 << " instead of 3 for field min_height";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[5].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Slot::Slot: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field min_height";

            throw Exception(ostr.str());
          }

          name = (*result)[5].name;

          if(strcmp(name, "min_height"))
          {
            std::ostringstream ostr;
            ostr << "Slot::Slot: unexpected name " << name
                 << " instead of min_height for field min_height";

            throw Exception(ostr.str());
          }

          if(use_columns >= 6)
          {
            return;
          }

          type = (*result)[6].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Slot::Slot: unexpected type " << type
                 << " instead of 3 for field max_height";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[6].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Slot::Slot: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field max_height";

            throw Exception(ostr.str());
          }

          name = (*result)[6].name;

          if(strcmp(name, "max_height"))
          {
            std::ostringstream ostr;
            ostr << "Slot::Slot: unexpected name " << name
                 << " instead of max_height for field max_height";

            throw Exception(ostr.str());
          }

        }

        inline
        El::MySQL::UnsignedLong
        Slot::id() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Slot::id: row_ is 0");
          }

          if(0 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Slot::id: unexpected index 0 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[0] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[0], lengths[0]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Slot::id: failed to convert 'id' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::String
        Slot::name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Slot::name: row_ is 0");
          }

          if(1 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Slot::name: unexpected index 1 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[1] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[1], lengths[1]);

          return tmp;
        }

        inline
        El::MySQL::String
        Slot::status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Slot::status: row_ is 0");
          }

          if(2 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Slot::status: unexpected index 2 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[2] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[2], lengths[2]);

          return tmp;
        }

        inline
        El::MySQL::UnsignedLong
        Slot::min_width() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Slot::min_width: row_ is 0");
          }

          if(3 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Slot::min_width: unexpected index 3 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[3] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[3], lengths[3]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Slot::min_width: failed to convert 'min_width' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::UnsignedLong
        Slot::max_width() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Slot::max_width: row_ is 0");
          }

          if(4 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Slot::max_width: unexpected index 4 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[4] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[4], lengths[4]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Slot::max_width: failed to convert 'max_width' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::UnsignedLong
        Slot::min_height() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Slot::min_height: row_ is 0");
          }

          if(5 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Slot::min_height: unexpected index 5 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[5] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[5], lengths[5]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Slot::min_height: failed to convert 'min_height' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::UnsignedLong
        Slot::max_height() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Slot::max_height: row_ is 0");
          }

          if(6 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Slot::max_height: unexpected index 6 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[6] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[6], lengths[6]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Slot::max_height: failed to convert 'max_height' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

      }
    }
  }
}

namespace NewsGate
{
  namespace Moderation
  {
    namespace Ad
    {
      namespace DB
      {
//
// Size class declaration
//
        class Size: public El::MySQL::Row
        {
        public:
          EL_EXCEPTION(Exception, El::MySQL::Exception);
          EL_EXCEPTION(IsNull, Exception);

        public:
          Size(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
            throw(Exception, El::Exception);

          El::MySQL::UnsignedLong id() const
           throw(Exception, El::Exception);

          El::MySQL::String name() const
           throw(Exception, El::Exception);

          El::MySQL::String status() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong width() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong height() const
           throw(Exception, El::Exception);

        };

//
// Size class definition
//
        inline
        Size::Size(El::MySQL::Result* result, unsigned long use_columns)
          throw(Exception, El::Exception)
            : Row(result)
        {
          unsigned long num_columns = std::min(use_columns, (unsigned long)5);

          if(result->num_fields() != num_columns)
          {
            std::ostringstream ostr;
            ostr << "Size::Size: unexpected number of fields "
                 << result->num_fields() << " instead of " << num_columns;

            throw Exception(ostr.str());
          }

          if(use_columns >= 0)
          {
            return;
          }

          enum_field_types type = (*result)[0].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Size::Size: unexpected type " << type
                 << " instead of 3 for field id";

            throw Exception(ostr.str());
          }

          unsigned int flags = 
            (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Size::Size: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field id";

            throw Exception(ostr.str());
          }

          const char* name = (*result)[0].name;

          if(strcmp(name, "id"))
          {
            std::ostringstream ostr;
            ostr << "Size::Size: unexpected name " << name
                 << " instead of id for field id";

            throw Exception(ostr.str());
          }

          if(use_columns >= 1)
          {
            return;
          }

          type = (*result)[1].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Size::Size: unexpected type " << type
                 << " instead of 254 for field name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Size::Size: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field name";

            throw Exception(ostr.str());
          }

          name = (*result)[1].name;

          if(strcmp(name, "name"))
          {
            std::ostringstream ostr;
            ostr << "Size::Size: unexpected name " << name
                 << " instead of name for field name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 2)
          {
            return;
          }

          type = (*result)[2].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Size::Size: unexpected type " << type
                 << " instead of 254 for field status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Size::Size: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field status";

            throw Exception(ostr.str());
          }

          name = (*result)[2].name;

          if(strcmp(name, "status"))
          {
            std::ostringstream ostr;
            ostr << "Size::Size: unexpected name " << name
                 << " instead of status for field status";

            throw Exception(ostr.str());
          }

          if(use_columns >= 3)
          {
            return;
          }

          type = (*result)[3].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Size::Size: unexpected type " << type
                 << " instead of 3 for field width";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[3].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Size::Size: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field width";

            throw Exception(ostr.str());
          }

          name = (*result)[3].name;

          if(strcmp(name, "width"))
          {
            std::ostringstream ostr;
            ostr << "Size::Size: unexpected name " << name
                 << " instead of width for field width";

            throw Exception(ostr.str());
          }

          if(use_columns >= 4)
          {
            return;
          }

          type = (*result)[4].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Size::Size: unexpected type " << type
                 << " instead of 3 for field height";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[4].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Size::Size: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field height";

            throw Exception(ostr.str());
          }

          name = (*result)[4].name;

          if(strcmp(name, "height"))
          {
            std::ostringstream ostr;
            ostr << "Size::Size: unexpected name " << name
                 << " instead of height for field height";

            throw Exception(ostr.str());
          }

        }

        inline
        El::MySQL::UnsignedLong
        Size::id() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Size::id: row_ is 0");
          }

          if(0 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Size::id: unexpected index 0 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[0] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[0], lengths[0]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Size::id: failed to convert 'id' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::String
        Size::name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Size::name: row_ is 0");
          }

          if(1 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Size::name: unexpected index 1 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[1] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[1], lengths[1]);

          return tmp;
        }

        inline
        El::MySQL::String
        Size::status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Size::status: row_ is 0");
          }

          if(2 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Size::status: unexpected index 2 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[2] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[2], lengths[2]);

          return tmp;
        }

        inline
        El::MySQL::UnsignedLong
        Size::width() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Size::width: row_ is 0");
          }

          if(3 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Size::width: unexpected index 3 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[3] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[3], lengths[3]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Size::width: failed to convert 'width' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::UnsignedLong
        Size::height() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Size::height: row_ is 0");
          }

          if(4 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Size::height: unexpected index 4 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[4] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[4], lengths[4]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Size::height: failed to convert 'height' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

      }
    }
  }
}

namespace NewsGate
{
  namespace Moderation
  {
    namespace Ad
    {
      namespace DB
      {
//
// Ad class declaration
//
        class Ad: public El::MySQL::Row
        {
        public:
          EL_EXCEPTION(Exception, El::MySQL::Exception);
          EL_EXCEPTION(IsNull, Exception);

        public:
          Ad(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
            throw(Exception, El::Exception);

          El::MySQL::UnsignedLongLong id() const
           throw(Exception, El::Exception);

          El::MySQL::String name() const
           throw(Exception, El::Exception);

          El::MySQL::String status() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong size() const
           throw(Exception, El::Exception);

          El::MySQL::String size_name() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong width() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong height() const
           throw(Exception, El::Exception);

          El::MySQL::String text() const
           throw(Exception, El::Exception);

        };

//
// Ad class definition
//
        inline
        Ad::Ad(El::MySQL::Result* result, unsigned long use_columns)
          throw(Exception, El::Exception)
            : Row(result)
        {
          unsigned long num_columns = std::min(use_columns, (unsigned long)8);

          if(result->num_fields() != num_columns)
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected number of fields "
                 << result->num_fields() << " instead of " << num_columns;

            throw Exception(ostr.str());
          }

          if(use_columns >= 0)
          {
            return;
          }

          enum_field_types type = (*result)[0].type;

          if(type != 8)
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected type " << type
                 << " instead of 8 for field id";

            throw Exception(ostr.str());
          }

          unsigned int flags = 
            (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field id";

            throw Exception(ostr.str());
          }

          const char* name = (*result)[0].name;

          if(strcmp(name, "id"))
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected name " << name
                 << " instead of id for field id";

            throw Exception(ostr.str());
          }

          if(use_columns >= 1)
          {
            return;
          }

          type = (*result)[1].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected type " << type
                 << " instead of 253 for field name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field name";

            throw Exception(ostr.str());
          }

          name = (*result)[1].name;

          if(strcmp(name, "name"))
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected name " << name
                 << " instead of name for field name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 2)
          {
            return;
          }

          type = (*result)[2].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected type " << type
                 << " instead of 254 for field status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field status";

            throw Exception(ostr.str());
          }

          name = (*result)[2].name;

          if(strcmp(name, "status"))
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected name " << name
                 << " instead of status for field status";

            throw Exception(ostr.str());
          }

          if(use_columns >= 3)
          {
            return;
          }

          type = (*result)[3].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected type " << type
                 << " instead of 3 for field size";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[3].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field size";

            throw Exception(ostr.str());
          }

          name = (*result)[3].name;

          if(strcmp(name, "size"))
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected name " << name
                 << " instead of size for field size";

            throw Exception(ostr.str());
          }

          if(use_columns >= 4)
          {
            return;
          }

          type = (*result)[4].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected type " << type
                 << " instead of 254 for field size_name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[4].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field size_name";

            throw Exception(ostr.str());
          }

          name = (*result)[4].name;

          if(strcmp(name, "size_name"))
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected name " << name
                 << " instead of size_name for field size_name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 5)
          {
            return;
          }

          type = (*result)[5].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected type " << type
                 << " instead of 3 for field width";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[5].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field width";

            throw Exception(ostr.str());
          }

          name = (*result)[5].name;

          if(strcmp(name, "width"))
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected name " << name
                 << " instead of width for field width";

            throw Exception(ostr.str());
          }

          if(use_columns >= 6)
          {
            return;
          }

          type = (*result)[6].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected type " << type
                 << " instead of 3 for field height";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[6].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field height";

            throw Exception(ostr.str());
          }

          name = (*result)[6].name;

          if(strcmp(name, "height"))
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected name " << name
                 << " instead of height for field height";

            throw Exception(ostr.str());
          }

          if(use_columns >= 7)
          {
            return;
          }

          type = (*result)[7].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected type " << type
                 << " instead of 253 for field text";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[7].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field text";

            throw Exception(ostr.str());
          }

          name = (*result)[7].name;

          if(strcmp(name, "text"))
          {
            std::ostringstream ostr;
            ostr << "Ad::Ad: unexpected name " << name
                 << " instead of text for field text";

            throw Exception(ostr.str());
          }

        }

        inline
        El::MySQL::UnsignedLongLong
        Ad::id() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Ad::id: row_ is 0");
          }

          if(0 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Ad::id: unexpected index 0 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long long value = 0;
          bool is_null = row_[0] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[0], lengths[0]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Ad::id: failed to convert 'id' field data"
                " to unsigned long long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLongLong(is_null, value);
        }

        inline
        El::MySQL::String
        Ad::name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Ad::name: row_ is 0");
          }

          if(1 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Ad::name: unexpected index 1 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[1] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[1], lengths[1]);

          return tmp;
        }

        inline
        El::MySQL::String
        Ad::status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Ad::status: row_ is 0");
          }

          if(2 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Ad::status: unexpected index 2 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[2] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[2], lengths[2]);

          return tmp;
        }

        inline
        El::MySQL::UnsignedLong
        Ad::size() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Ad::size: row_ is 0");
          }

          if(3 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Ad::size: unexpected index 3 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[3] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[3], lengths[3]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Ad::size: failed to convert 'size' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::String
        Ad::size_name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Ad::size_name: row_ is 0");
          }

          if(4 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Ad::size_name: unexpected index 4 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[4] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[4], lengths[4]);

          return tmp;
        }

        inline
        El::MySQL::UnsignedLong
        Ad::width() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Ad::width: row_ is 0");
          }

          if(5 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Ad::width: unexpected index 5 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[5] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[5], lengths[5]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Ad::width: failed to convert 'width' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::UnsignedLong
        Ad::height() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Ad::height: row_ is 0");
          }

          if(6 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Ad::height: unexpected index 6 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[6] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[6], lengths[6]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Ad::height: failed to convert 'height' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::String
        Ad::text() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Ad::text: row_ is 0");
          }

          if(7 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Ad::text: unexpected index 7 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[7] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[7], lengths[7]);

          return tmp;
        }

      }
    }
  }
}

namespace NewsGate
{
  namespace Moderation
  {
    namespace Ad
    {
      namespace DB
      {
//
// Counter class declaration
//
        class Counter: public El::MySQL::Row
        {
        public:
          EL_EXCEPTION(Exception, El::MySQL::Exception);
          EL_EXCEPTION(IsNull, Exception);

        public:
          Counter(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
            throw(Exception, El::Exception);

          El::MySQL::UnsignedLongLong id() const
           throw(Exception, El::Exception);

          El::MySQL::String name() const
           throw(Exception, El::Exception);

          El::MySQL::String status() const
           throw(Exception, El::Exception);

          El::MySQL::String text() const
           throw(Exception, El::Exception);

        };

//
// Counter class definition
//
        inline
        Counter::Counter(El::MySQL::Result* result, unsigned long use_columns)
          throw(Exception, El::Exception)
            : Row(result)
        {
          unsigned long num_columns = std::min(use_columns, (unsigned long)4);

          if(result->num_fields() != num_columns)
          {
            std::ostringstream ostr;
            ostr << "Counter::Counter: unexpected number of fields "
                 << result->num_fields() << " instead of " << num_columns;

            throw Exception(ostr.str());
          }

          if(use_columns >= 0)
          {
            return;
          }

          enum_field_types type = (*result)[0].type;

          if(type != 8)
          {
            std::ostringstream ostr;
            ostr << "Counter::Counter: unexpected type " << type
                 << " instead of 8 for field id";

            throw Exception(ostr.str());
          }

          unsigned int flags = 
            (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Counter::Counter: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field id";

            throw Exception(ostr.str());
          }

          const char* name = (*result)[0].name;

          if(strcmp(name, "id"))
          {
            std::ostringstream ostr;
            ostr << "Counter::Counter: unexpected name " << name
                 << " instead of id for field id";

            throw Exception(ostr.str());
          }

          if(use_columns >= 1)
          {
            return;
          }

          type = (*result)[1].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Counter::Counter: unexpected type " << type
                 << " instead of 253 for field name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Counter::Counter: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field name";

            throw Exception(ostr.str());
          }

          name = (*result)[1].name;

          if(strcmp(name, "name"))
          {
            std::ostringstream ostr;
            ostr << "Counter::Counter: unexpected name " << name
                 << " instead of name for field name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 2)
          {
            return;
          }

          type = (*result)[2].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Counter::Counter: unexpected type " << type
                 << " instead of 254 for field status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Counter::Counter: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field status";

            throw Exception(ostr.str());
          }

          name = (*result)[2].name;

          if(strcmp(name, "status"))
          {
            std::ostringstream ostr;
            ostr << "Counter::Counter: unexpected name " << name
                 << " instead of status for field status";

            throw Exception(ostr.str());
          }

          if(use_columns >= 3)
          {
            return;
          }

          type = (*result)[3].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Counter::Counter: unexpected type " << type
                 << " instead of 253 for field text";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[3].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Counter::Counter: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field text";

            throw Exception(ostr.str());
          }

          name = (*result)[3].name;

          if(strcmp(name, "text"))
          {
            std::ostringstream ostr;
            ostr << "Counter::Counter: unexpected name " << name
                 << " instead of text for field text";

            throw Exception(ostr.str());
          }

        }

        inline
        El::MySQL::UnsignedLongLong
        Counter::id() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Counter::id: row_ is 0");
          }

          if(0 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Counter::id: unexpected index 0 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long long value = 0;
          bool is_null = row_[0] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[0], lengths[0]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Counter::id: failed to convert 'id' field data"
                " to unsigned long long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLongLong(is_null, value);
        }

        inline
        El::MySQL::String
        Counter::name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Counter::name: row_ is 0");
          }

          if(1 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Counter::name: unexpected index 1 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[1] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[1], lengths[1]);

          return tmp;
        }

        inline
        El::MySQL::String
        Counter::status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Counter::status: row_ is 0");
          }

          if(2 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Counter::status: unexpected index 2 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[2] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[2], lengths[2]);

          return tmp;
        }

        inline
        El::MySQL::String
        Counter::text() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Counter::text: row_ is 0");
          }

          if(3 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Counter::text: unexpected index 3 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[3] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[3], lengths[3]);

          return tmp;
        }

      }
    }
  }
}

namespace NewsGate
{
  namespace Moderation
  {
    namespace Ad
    {
      namespace DB
      {
//
// Condition class declaration
//
        class Condition: public El::MySQL::Row
        {
        public:
          EL_EXCEPTION(Exception, El::MySQL::Exception);
          EL_EXCEPTION(IsNull, Exception);

        public:
          Condition(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
            throw(Exception, El::Exception);

          El::MySQL::UnsignedLongLong id() const
           throw(Exception, El::Exception);

          El::MySQL::String name() const
           throw(Exception, El::Exception);

          El::MySQL::String status() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedChar rnd_mod() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedChar rnd_mod_from() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedChar rnd_mod_to() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong group_freq_cap() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong group_count_cap() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLongLong query_types() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLongLong query_type_exclusions() const
           throw(Exception, El::Exception);

          El::MySQL::String page_sources() const
           throw(Exception, El::Exception);

          El::MySQL::String page_source_exclusions() const
           throw(Exception, El::Exception);

          El::MySQL::String message_sources() const
           throw(Exception, El::Exception);

          El::MySQL::String message_source_exclusions() const
           throw(Exception, El::Exception);

          El::MySQL::String page_categories() const
           throw(Exception, El::Exception);

          El::MySQL::String page_category_exclusions() const
           throw(Exception, El::Exception);

          El::MySQL::String message_categories() const
           throw(Exception, El::Exception);

          El::MySQL::String message_category_exclusions() const
           throw(Exception, El::Exception);

          El::MySQL::String search_engines() const
           throw(Exception, El::Exception);

          El::MySQL::String search_engine_exclusions() const
           throw(Exception, El::Exception);

          El::MySQL::String crawlers() const
           throw(Exception, El::Exception);

          El::MySQL::String crawler_exclusions() const
           throw(Exception, El::Exception);

          El::MySQL::String languages() const
           throw(Exception, El::Exception);

          El::MySQL::String language_exclusions() const
           throw(Exception, El::Exception);

          El::MySQL::String countries() const
           throw(Exception, El::Exception);

          El::MySQL::String country_exclusions() const
           throw(Exception, El::Exception);

          El::MySQL::String ip_masks() const
           throw(Exception, El::Exception);

          El::MySQL::String ip_mask_exclusions() const
           throw(Exception, El::Exception);

          El::MySQL::String tags() const
           throw(Exception, El::Exception);

          El::MySQL::String tag_exclusions() const
           throw(Exception, El::Exception);

          El::MySQL::String referers() const
           throw(Exception, El::Exception);

          El::MySQL::String referer_exclusions() const
           throw(Exception, El::Exception);

          El::MySQL::String content_languages() const
           throw(Exception, El::Exception);

          El::MySQL::String content_language_exclusions() const
           throw(Exception, El::Exception);

        };

//
// Condition class definition
//
        inline
        Condition::Condition(El::MySQL::Result* result, unsigned long use_columns)
          throw(Exception, El::Exception)
            : Row(result)
        {
          unsigned long num_columns = std::min(use_columns, (unsigned long)34);

          if(result->num_fields() != num_columns)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected number of fields "
                 << result->num_fields() << " instead of " << num_columns;

            throw Exception(ostr.str());
          }

          if(use_columns >= 0)
          {
            return;
          }

          enum_field_types type = (*result)[0].type;

          if(type != 8)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 8 for field id";

            throw Exception(ostr.str());
          }

          unsigned int flags = 
            (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field id";

            throw Exception(ostr.str());
          }

          const char* name = (*result)[0].name;

          if(strcmp(name, "id"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of id for field id";

            throw Exception(ostr.str());
          }

          if(use_columns >= 1)
          {
            return;
          }

          type = (*result)[1].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 253 for field name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field name";

            throw Exception(ostr.str());
          }

          name = (*result)[1].name;

          if(strcmp(name, "name"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of name for field name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 2)
          {
            return;
          }

          type = (*result)[2].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 254 for field status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field status";

            throw Exception(ostr.str());
          }

          name = (*result)[2].name;

          if(strcmp(name, "status"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of status for field status";

            throw Exception(ostr.str());
          }

          if(use_columns >= 3)
          {
            return;
          }

          type = (*result)[3].type;

          if(type != 1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 1 for field rnd_mod";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[3].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field rnd_mod";

            throw Exception(ostr.str());
          }

          name = (*result)[3].name;

          if(strcmp(name, "rnd_mod"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of rnd_mod for field rnd_mod";

            throw Exception(ostr.str());
          }

          if(use_columns >= 4)
          {
            return;
          }

          type = (*result)[4].type;

          if(type != 1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 1 for field rnd_mod_from";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[4].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field rnd_mod_from";

            throw Exception(ostr.str());
          }

          name = (*result)[4].name;

          if(strcmp(name, "rnd_mod_from"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of rnd_mod_from for field rnd_mod_from";

            throw Exception(ostr.str());
          }

          if(use_columns >= 5)
          {
            return;
          }

          type = (*result)[5].type;

          if(type != 1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 1 for field rnd_mod_to";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[5].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field rnd_mod_to";

            throw Exception(ostr.str());
          }

          name = (*result)[5].name;

          if(strcmp(name, "rnd_mod_to"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of rnd_mod_to for field rnd_mod_to";

            throw Exception(ostr.str());
          }

          if(use_columns >= 6)
          {
            return;
          }

          type = (*result)[6].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 3 for field group_freq_cap";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[6].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field group_freq_cap";

            throw Exception(ostr.str());
          }

          name = (*result)[6].name;

          if(strcmp(name, "group_freq_cap"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of group_freq_cap for field group_freq_cap";

            throw Exception(ostr.str());
          }

          if(use_columns >= 7)
          {
            return;
          }

          type = (*result)[7].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 3 for field group_count_cap";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[7].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field group_count_cap";

            throw Exception(ostr.str());
          }

          name = (*result)[7].name;

          if(strcmp(name, "group_count_cap"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of group_count_cap for field group_count_cap";

            throw Exception(ostr.str());
          }

          if(use_columns >= 8)
          {
            return;
          }

          type = (*result)[8].type;

          if(type != 8)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 8 for field query_types";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[8].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field query_types";

            throw Exception(ostr.str());
          }

          name = (*result)[8].name;

          if(strcmp(name, "query_types"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of query_types for field query_types";

            throw Exception(ostr.str());
          }

          if(use_columns >= 9)
          {
            return;
          }

          type = (*result)[9].type;

          if(type != 8)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 8 for field query_type_exclusions";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[9].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field query_type_exclusions";

            throw Exception(ostr.str());
          }

          name = (*result)[9].name;

          if(strcmp(name, "query_type_exclusions"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of query_type_exclusions for field query_type_exclusions";

            throw Exception(ostr.str());
          }

          if(use_columns >= 10)
          {
            return;
          }

          type = (*result)[10].type;

          if(type != 252)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 252 for field page_sources";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[10].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field page_sources";

            throw Exception(ostr.str());
          }

          name = (*result)[10].name;

          if(strcmp(name, "page_sources"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of page_sources for field page_sources";

            throw Exception(ostr.str());
          }

          if(use_columns >= 11)
          {
            return;
          }

          type = (*result)[11].type;

          if(type != 252)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 252 for field page_source_exclusions";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[11].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field page_source_exclusions";

            throw Exception(ostr.str());
          }

          name = (*result)[11].name;

          if(strcmp(name, "page_source_exclusions"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of page_source_exclusions for field page_source_exclusions";

            throw Exception(ostr.str());
          }

          if(use_columns >= 12)
          {
            return;
          }

          type = (*result)[12].type;

          if(type != 252)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 252 for field message_sources";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[12].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field message_sources";

            throw Exception(ostr.str());
          }

          name = (*result)[12].name;

          if(strcmp(name, "message_sources"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of message_sources for field message_sources";

            throw Exception(ostr.str());
          }

          if(use_columns >= 13)
          {
            return;
          }

          type = (*result)[13].type;

          if(type != 252)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 252 for field message_source_exclusions";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[13].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field message_source_exclusions";

            throw Exception(ostr.str());
          }

          name = (*result)[13].name;

          if(strcmp(name, "message_source_exclusions"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of message_source_exclusions for field message_source_exclusions";

            throw Exception(ostr.str());
          }

          if(use_columns >= 14)
          {
            return;
          }

          type = (*result)[14].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 253 for field page_categories";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[14].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field page_categories";

            throw Exception(ostr.str());
          }

          name = (*result)[14].name;

          if(strcmp(name, "page_categories"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of page_categories for field page_categories";

            throw Exception(ostr.str());
          }

          if(use_columns >= 15)
          {
            return;
          }

          type = (*result)[15].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 253 for field page_category_exclusions";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[15].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field page_category_exclusions";

            throw Exception(ostr.str());
          }

          name = (*result)[15].name;

          if(strcmp(name, "page_category_exclusions"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of page_category_exclusions for field page_category_exclusions";

            throw Exception(ostr.str());
          }

          if(use_columns >= 16)
          {
            return;
          }

          type = (*result)[16].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 253 for field message_categories";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[16].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field message_categories";

            throw Exception(ostr.str());
          }

          name = (*result)[16].name;

          if(strcmp(name, "message_categories"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of message_categories for field message_categories";

            throw Exception(ostr.str());
          }

          if(use_columns >= 17)
          {
            return;
          }

          type = (*result)[17].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 253 for field message_category_exclusions";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[17].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field message_category_exclusions";

            throw Exception(ostr.str());
          }

          name = (*result)[17].name;

          if(strcmp(name, "message_category_exclusions"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of message_category_exclusions for field message_category_exclusions";

            throw Exception(ostr.str());
          }

          if(use_columns >= 18)
          {
            return;
          }

          type = (*result)[18].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 253 for field search_engines";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[18].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field search_engines";

            throw Exception(ostr.str());
          }

          name = (*result)[18].name;

          if(strcmp(name, "search_engines"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of search_engines for field search_engines";

            throw Exception(ostr.str());
          }

          if(use_columns >= 19)
          {
            return;
          }

          type = (*result)[19].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 253 for field search_engine_exclusions";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[19].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field search_engine_exclusions";

            throw Exception(ostr.str());
          }

          name = (*result)[19].name;

          if(strcmp(name, "search_engine_exclusions"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of search_engine_exclusions for field search_engine_exclusions";

            throw Exception(ostr.str());
          }

          if(use_columns >= 20)
          {
            return;
          }

          type = (*result)[20].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 253 for field crawlers";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[20].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field crawlers";

            throw Exception(ostr.str());
          }

          name = (*result)[20].name;

          if(strcmp(name, "crawlers"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of crawlers for field crawlers";

            throw Exception(ostr.str());
          }

          if(use_columns >= 21)
          {
            return;
          }

          type = (*result)[21].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 253 for field crawler_exclusions";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[21].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field crawler_exclusions";

            throw Exception(ostr.str());
          }

          name = (*result)[21].name;

          if(strcmp(name, "crawler_exclusions"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of crawler_exclusions for field crawler_exclusions";

            throw Exception(ostr.str());
          }

          if(use_columns >= 22)
          {
            return;
          }

          type = (*result)[22].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 253 for field languages";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[22].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field languages";

            throw Exception(ostr.str());
          }

          name = (*result)[22].name;

          if(strcmp(name, "languages"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of languages for field languages";

            throw Exception(ostr.str());
          }

          if(use_columns >= 23)
          {
            return;
          }

          type = (*result)[23].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 253 for field language_exclusions";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[23].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field language_exclusions";

            throw Exception(ostr.str());
          }

          name = (*result)[23].name;

          if(strcmp(name, "language_exclusions"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of language_exclusions for field language_exclusions";

            throw Exception(ostr.str());
          }

          if(use_columns >= 24)
          {
            return;
          }

          type = (*result)[24].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 253 for field countries";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[24].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field countries";

            throw Exception(ostr.str());
          }

          name = (*result)[24].name;

          if(strcmp(name, "countries"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of countries for field countries";

            throw Exception(ostr.str());
          }

          if(use_columns >= 25)
          {
            return;
          }

          type = (*result)[25].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 253 for field country_exclusions";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[25].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field country_exclusions";

            throw Exception(ostr.str());
          }

          name = (*result)[25].name;

          if(strcmp(name, "country_exclusions"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of country_exclusions for field country_exclusions";

            throw Exception(ostr.str());
          }

          if(use_columns >= 26)
          {
            return;
          }

          type = (*result)[26].type;

          if(type != 252)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 252 for field ip_masks";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[26].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field ip_masks";

            throw Exception(ostr.str());
          }

          name = (*result)[26].name;

          if(strcmp(name, "ip_masks"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of ip_masks for field ip_masks";

            throw Exception(ostr.str());
          }

          if(use_columns >= 27)
          {
            return;
          }

          type = (*result)[27].type;

          if(type != 252)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 252 for field ip_mask_exclusions";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[27].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field ip_mask_exclusions";

            throw Exception(ostr.str());
          }

          name = (*result)[27].name;

          if(strcmp(name, "ip_mask_exclusions"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of ip_mask_exclusions for field ip_mask_exclusions";

            throw Exception(ostr.str());
          }

          if(use_columns >= 28)
          {
            return;
          }

          type = (*result)[28].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 253 for field tags";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[28].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field tags";

            throw Exception(ostr.str());
          }

          name = (*result)[28].name;

          if(strcmp(name, "tags"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of tags for field tags";

            throw Exception(ostr.str());
          }

          if(use_columns >= 29)
          {
            return;
          }

          type = (*result)[29].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 253 for field tag_exclusions";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[29].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field tag_exclusions";

            throw Exception(ostr.str());
          }

          name = (*result)[29].name;

          if(strcmp(name, "tag_exclusions"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of tag_exclusions for field tag_exclusions";

            throw Exception(ostr.str());
          }

          if(use_columns >= 30)
          {
            return;
          }

          type = (*result)[30].type;

          if(type != 252)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 252 for field referers";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[30].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field referers";

            throw Exception(ostr.str());
          }

          name = (*result)[30].name;

          if(strcmp(name, "referers"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of referers for field referers";

            throw Exception(ostr.str());
          }

          if(use_columns >= 31)
          {
            return;
          }

          type = (*result)[31].type;

          if(type != 252)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 252 for field referer_exclusions";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[31].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field referer_exclusions";

            throw Exception(ostr.str());
          }

          name = (*result)[31].name;

          if(strcmp(name, "referer_exclusions"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of referer_exclusions for field referer_exclusions";

            throw Exception(ostr.str());
          }

          if(use_columns >= 32)
          {
            return;
          }

          type = (*result)[32].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 253 for field content_languages";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[32].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field content_languages";

            throw Exception(ostr.str());
          }

          name = (*result)[32].name;

          if(strcmp(name, "content_languages"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of content_languages for field content_languages";

            throw Exception(ostr.str());
          }

          if(use_columns >= 33)
          {
            return;
          }

          type = (*result)[33].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected type " << type
                 << " instead of 253 for field content_language_exclusions";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[33].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field content_language_exclusions";

            throw Exception(ostr.str());
          }

          name = (*result)[33].name;

          if(strcmp(name, "content_language_exclusions"))
          {
            std::ostringstream ostr;
            ostr << "Condition::Condition: unexpected name " << name
                 << " instead of content_language_exclusions for field content_language_exclusions";

            throw Exception(ostr.str());
          }

        }

        inline
        El::MySQL::UnsignedLongLong
        Condition::id() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::id: row_ is 0");
          }

          if(0 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::id: unexpected index 0 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long long value = 0;
          bool is_null = row_[0] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[0], lengths[0]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Condition::id: failed to convert 'id' field data"
                " to unsigned long long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLongLong(is_null, value);
        }

        inline
        El::MySQL::String
        Condition::name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::name: row_ is 0");
          }

          if(1 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::name: unexpected index 1 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[1] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[1], lengths[1]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::status: row_ is 0");
          }

          if(2 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::status: unexpected index 2 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[2] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[2], lengths[2]);

          return tmp;
        }

        inline
        El::MySQL::UnsignedChar
        Condition::rnd_mod() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::rnd_mod: row_ is 0");
          }

          if(3 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::rnd_mod: unexpected index 3 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned short value = 0;
          bool is_null = row_[3] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[3], lengths[3]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Condition::rnd_mod: failed to convert 'rnd_mod' field data"
                " to unsigned short";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedChar(is_null, value);
        }

        inline
        El::MySQL::UnsignedChar
        Condition::rnd_mod_from() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::rnd_mod_from: row_ is 0");
          }

          if(4 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::rnd_mod_from: unexpected index 4 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned short value = 0;
          bool is_null = row_[4] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[4], lengths[4]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Condition::rnd_mod_from: failed to convert 'rnd_mod_from' field data"
                " to unsigned short";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedChar(is_null, value);
        }

        inline
        El::MySQL::UnsignedChar
        Condition::rnd_mod_to() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::rnd_mod_to: row_ is 0");
          }

          if(5 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::rnd_mod_to: unexpected index 5 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned short value = 0;
          bool is_null = row_[5] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[5], lengths[5]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Condition::rnd_mod_to: failed to convert 'rnd_mod_to' field data"
                " to unsigned short";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedChar(is_null, value);
        }

        inline
        El::MySQL::UnsignedLong
        Condition::group_freq_cap() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::group_freq_cap: row_ is 0");
          }

          if(6 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::group_freq_cap: unexpected index 6 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[6] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[6], lengths[6]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Condition::group_freq_cap: failed to convert 'group_freq_cap' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::UnsignedLong
        Condition::group_count_cap() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::group_count_cap: row_ is 0");
          }

          if(7 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::group_count_cap: unexpected index 7 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[7] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[7], lengths[7]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Condition::group_count_cap: failed to convert 'group_count_cap' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::UnsignedLongLong
        Condition::query_types() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::query_types: row_ is 0");
          }

          if(8 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::query_types: unexpected index 8 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long long value = 0;
          bool is_null = row_[8] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[8], lengths[8]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Condition::query_types: failed to convert 'query_types' field data"
                " to unsigned long long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLongLong(is_null, value);
        }

        inline
        El::MySQL::UnsignedLongLong
        Condition::query_type_exclusions() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::query_type_exclusions: row_ is 0");
          }

          if(9 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::query_type_exclusions: unexpected index 9 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long long value = 0;
          bool is_null = row_[9] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[9], lengths[9]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Condition::query_type_exclusions: failed to convert 'query_type_exclusions' field data"
                " to unsigned long long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLongLong(is_null, value);
        }

        inline
        El::MySQL::String
        Condition::page_sources() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::page_sources: row_ is 0");
          }

          if(10 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::page_sources: unexpected index 10 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[10] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[10], lengths[10]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::page_source_exclusions() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::page_source_exclusions: row_ is 0");
          }

          if(11 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::page_source_exclusions: unexpected index 11 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[11] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[11], lengths[11]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::message_sources() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::message_sources: row_ is 0");
          }

          if(12 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::message_sources: unexpected index 12 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[12] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[12], lengths[12]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::message_source_exclusions() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::message_source_exclusions: row_ is 0");
          }

          if(13 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::message_source_exclusions: unexpected index 13 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[13] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[13], lengths[13]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::page_categories() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::page_categories: row_ is 0");
          }

          if(14 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::page_categories: unexpected index 14 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[14] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[14], lengths[14]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::page_category_exclusions() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::page_category_exclusions: row_ is 0");
          }

          if(15 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::page_category_exclusions: unexpected index 15 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[15] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[15], lengths[15]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::message_categories() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::message_categories: row_ is 0");
          }

          if(16 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::message_categories: unexpected index 16 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[16] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[16], lengths[16]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::message_category_exclusions() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::message_category_exclusions: row_ is 0");
          }

          if(17 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::message_category_exclusions: unexpected index 17 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[17] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[17], lengths[17]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::search_engines() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::search_engines: row_ is 0");
          }

          if(18 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::search_engines: unexpected index 18 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[18] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[18], lengths[18]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::search_engine_exclusions() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::search_engine_exclusions: row_ is 0");
          }

          if(19 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::search_engine_exclusions: unexpected index 19 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[19] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[19], lengths[19]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::crawlers() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::crawlers: row_ is 0");
          }

          if(20 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::crawlers: unexpected index 20 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[20] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[20], lengths[20]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::crawler_exclusions() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::crawler_exclusions: row_ is 0");
          }

          if(21 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::crawler_exclusions: unexpected index 21 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[21] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[21], lengths[21]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::languages() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::languages: row_ is 0");
          }

          if(22 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::languages: unexpected index 22 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[22] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[22], lengths[22]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::language_exclusions() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::language_exclusions: row_ is 0");
          }

          if(23 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::language_exclusions: unexpected index 23 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[23] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[23], lengths[23]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::countries() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::countries: row_ is 0");
          }

          if(24 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::countries: unexpected index 24 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[24] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[24], lengths[24]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::country_exclusions() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::country_exclusions: row_ is 0");
          }

          if(25 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::country_exclusions: unexpected index 25 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[25] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[25], lengths[25]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::ip_masks() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::ip_masks: row_ is 0");
          }

          if(26 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::ip_masks: unexpected index 26 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[26] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[26], lengths[26]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::ip_mask_exclusions() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::ip_mask_exclusions: row_ is 0");
          }

          if(27 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::ip_mask_exclusions: unexpected index 27 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[27] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[27], lengths[27]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::tags() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::tags: row_ is 0");
          }

          if(28 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::tags: unexpected index 28 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[28] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[28], lengths[28]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::tag_exclusions() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::tag_exclusions: row_ is 0");
          }

          if(29 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::tag_exclusions: unexpected index 29 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[29] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[29], lengths[29]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::referers() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::referers: row_ is 0");
          }

          if(30 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::referers: unexpected index 30 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[30] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[30], lengths[30]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::referer_exclusions() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::referer_exclusions: row_ is 0");
          }

          if(31 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::referer_exclusions: unexpected index 31 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[31] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[31], lengths[31]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::content_languages() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::content_languages: row_ is 0");
          }

          if(32 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::content_languages: unexpected index 32 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[32] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[32], lengths[32]);

          return tmp;
        }

        inline
        El::MySQL::String
        Condition::content_language_exclusions() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Condition::content_language_exclusions: row_ is 0");
          }

          if(33 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Condition::content_language_exclusions: unexpected index 33 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[33] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[33], lengths[33]);

          return tmp;
        }

      }
    }
  }
}

namespace NewsGate
{
  namespace Moderation
  {
    namespace Ad
    {
      namespace DB
      {
//
// Campaign class declaration
//
        class Campaign: public El::MySQL::Row
        {
        public:
          EL_EXCEPTION(Exception, El::MySQL::Exception);
          EL_EXCEPTION(IsNull, Exception);

        public:
          Campaign(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
            throw(Exception, El::Exception);

          El::MySQL::UnsignedLongLong id() const
           throw(Exception, El::Exception);

          El::MySQL::String name() const
           throw(Exception, El::Exception);

          El::MySQL::String status() const
           throw(Exception, El::Exception);

        };

//
// Campaign class definition
//
        inline
        Campaign::Campaign(El::MySQL::Result* result, unsigned long use_columns)
          throw(Exception, El::Exception)
            : Row(result)
        {
          unsigned long num_columns = std::min(use_columns, (unsigned long)3);

          if(result->num_fields() != num_columns)
          {
            std::ostringstream ostr;
            ostr << "Campaign::Campaign: unexpected number of fields "
                 << result->num_fields() << " instead of " << num_columns;

            throw Exception(ostr.str());
          }

          if(use_columns >= 0)
          {
            return;
          }

          enum_field_types type = (*result)[0].type;

          if(type != 8)
          {
            std::ostringstream ostr;
            ostr << "Campaign::Campaign: unexpected type " << type
                 << " instead of 8 for field id";

            throw Exception(ostr.str());
          }

          unsigned int flags = 
            (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Campaign::Campaign: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field id";

            throw Exception(ostr.str());
          }

          const char* name = (*result)[0].name;

          if(strcmp(name, "id"))
          {
            std::ostringstream ostr;
            ostr << "Campaign::Campaign: unexpected name " << name
                 << " instead of id for field id";

            throw Exception(ostr.str());
          }

          if(use_columns >= 1)
          {
            return;
          }

          type = (*result)[1].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Campaign::Campaign: unexpected type " << type
                 << " instead of 253 for field name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Campaign::Campaign: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field name";

            throw Exception(ostr.str());
          }

          name = (*result)[1].name;

          if(strcmp(name, "name"))
          {
            std::ostringstream ostr;
            ostr << "Campaign::Campaign: unexpected name " << name
                 << " instead of name for field name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 2)
          {
            return;
          }

          type = (*result)[2].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Campaign::Campaign: unexpected type " << type
                 << " instead of 254 for field status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Campaign::Campaign: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field status";

            throw Exception(ostr.str());
          }

          name = (*result)[2].name;

          if(strcmp(name, "status"))
          {
            std::ostringstream ostr;
            ostr << "Campaign::Campaign: unexpected name " << name
                 << " instead of status for field status";

            throw Exception(ostr.str());
          }

        }

        inline
        El::MySQL::UnsignedLongLong
        Campaign::id() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Campaign::id: row_ is 0");
          }

          if(0 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Campaign::id: unexpected index 0 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long long value = 0;
          bool is_null = row_[0] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[0], lengths[0]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Campaign::id: failed to convert 'id' field data"
                " to unsigned long long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLongLong(is_null, value);
        }

        inline
        El::MySQL::String
        Campaign::name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Campaign::name: row_ is 0");
          }

          if(1 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Campaign::name: unexpected index 1 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[1] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[1], lengths[1]);

          return tmp;
        }

        inline
        El::MySQL::String
        Campaign::status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Campaign::status: row_ is 0");
          }

          if(2 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Campaign::status: unexpected index 2 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[2] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[2], lengths[2]);

          return tmp;
        }

      }
    }
  }
}

namespace NewsGate
{
  namespace Moderation
  {
    namespace Ad
    {
      namespace DB
      {
//
// Group class declaration
//
        class Group: public El::MySQL::Row
        {
        public:
          EL_EXCEPTION(Exception, El::MySQL::Exception);
          EL_EXCEPTION(IsNull, Exception);

        public:
          Group(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
            throw(Exception, El::Exception);

          El::MySQL::UnsignedLongLong id() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLongLong campaign() const
           throw(Exception, El::Exception);

          El::MySQL::String campaign_name() const
           throw(Exception, El::Exception);

          El::MySQL::String name() const
           throw(Exception, El::Exception);

          El::MySQL::String status() const
           throw(Exception, El::Exception);

          El::MySQL::Double auction_factor() const
           throw(Exception, El::Exception);

        };

//
// Group class definition
//
        inline
        Group::Group(El::MySQL::Result* result, unsigned long use_columns)
          throw(Exception, El::Exception)
            : Row(result)
        {
          unsigned long num_columns = std::min(use_columns, (unsigned long)6);

          if(result->num_fields() != num_columns)
          {
            std::ostringstream ostr;
            ostr << "Group::Group: unexpected number of fields "
                 << result->num_fields() << " instead of " << num_columns;

            throw Exception(ostr.str());
          }

          if(use_columns >= 0)
          {
            return;
          }

          enum_field_types type = (*result)[0].type;

          if(type != 8)
          {
            std::ostringstream ostr;
            ostr << "Group::Group: unexpected type " << type
                 << " instead of 8 for field id";

            throw Exception(ostr.str());
          }

          unsigned int flags = 
            (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Group::Group: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field id";

            throw Exception(ostr.str());
          }

          const char* name = (*result)[0].name;

          if(strcmp(name, "id"))
          {
            std::ostringstream ostr;
            ostr << "Group::Group: unexpected name " << name
                 << " instead of id for field id";

            throw Exception(ostr.str());
          }

          if(use_columns >= 1)
          {
            return;
          }

          type = (*result)[1].type;

          if(type != 8)
          {
            std::ostringstream ostr;
            ostr << "Group::Group: unexpected type " << type
                 << " instead of 8 for field campaign";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Group::Group: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field campaign";

            throw Exception(ostr.str());
          }

          name = (*result)[1].name;

          if(strcmp(name, "campaign"))
          {
            std::ostringstream ostr;
            ostr << "Group::Group: unexpected name " << name
                 << " instead of campaign for field campaign";

            throw Exception(ostr.str());
          }

          if(use_columns >= 2)
          {
            return;
          }

          type = (*result)[2].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Group::Group: unexpected type " << type
                 << " instead of 253 for field campaign_name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Group::Group: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field campaign_name";

            throw Exception(ostr.str());
          }

          name = (*result)[2].name;

          if(strcmp(name, "campaign_name"))
          {
            std::ostringstream ostr;
            ostr << "Group::Group: unexpected name " << name
                 << " instead of campaign_name for field campaign_name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 3)
          {
            return;
          }

          type = (*result)[3].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Group::Group: unexpected type " << type
                 << " instead of 253 for field name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[3].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Group::Group: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field name";

            throw Exception(ostr.str());
          }

          name = (*result)[3].name;

          if(strcmp(name, "name"))
          {
            std::ostringstream ostr;
            ostr << "Group::Group: unexpected name " << name
                 << " instead of name for field name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 4)
          {
            return;
          }

          type = (*result)[4].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Group::Group: unexpected type " << type
                 << " instead of 254 for field status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[4].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Group::Group: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field status";

            throw Exception(ostr.str());
          }

          name = (*result)[4].name;

          if(strcmp(name, "status"))
          {
            std::ostringstream ostr;
            ostr << "Group::Group: unexpected name " << name
                 << " instead of status for field status";

            throw Exception(ostr.str());
          }

          if(use_columns >= 5)
          {
            return;
          }

          type = (*result)[5].type;

          if(type != 5)
          {
            std::ostringstream ostr;
            ostr << "Group::Group: unexpected type " << type
                 << " instead of 5 for field auction_factor";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[5].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Group::Group: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field auction_factor";

            throw Exception(ostr.str());
          }

          name = (*result)[5].name;

          if(strcmp(name, "auction_factor"))
          {
            std::ostringstream ostr;
            ostr << "Group::Group: unexpected name " << name
                 << " instead of auction_factor for field auction_factor";

            throw Exception(ostr.str());
          }

        }

        inline
        El::MySQL::UnsignedLongLong
        Group::id() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Group::id: row_ is 0");
          }

          if(0 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Group::id: unexpected index 0 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long long value = 0;
          bool is_null = row_[0] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[0], lengths[0]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Group::id: failed to convert 'id' field data"
                " to unsigned long long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLongLong(is_null, value);
        }

        inline
        El::MySQL::UnsignedLongLong
        Group::campaign() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Group::campaign: row_ is 0");
          }

          if(1 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Group::campaign: unexpected index 1 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long long value = 0;
          bool is_null = row_[1] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[1], lengths[1]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Group::campaign: failed to convert 'campaign' field data"
                " to unsigned long long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLongLong(is_null, value);
        }

        inline
        El::MySQL::String
        Group::campaign_name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Group::campaign_name: row_ is 0");
          }

          if(2 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Group::campaign_name: unexpected index 2 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[2] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[2], lengths[2]);

          return tmp;
        }

        inline
        El::MySQL::String
        Group::name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Group::name: row_ is 0");
          }

          if(3 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Group::name: unexpected index 3 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[3] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[3], lengths[3]);

          return tmp;
        }

        inline
        El::MySQL::String
        Group::status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Group::status: row_ is 0");
          }

          if(4 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Group::status: unexpected index 4 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[4] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[4], lengths[4]);

          return tmp;
        }

        inline
        El::MySQL::Double
        Group::auction_factor() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Group::auction_factor: row_ is 0");
          }

          if(5 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Group::auction_factor: unexpected index 5 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          double value = 0;
          bool is_null = row_[5] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[5], lengths[5]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Group::auction_factor: failed to convert 'auction_factor' field data"
                " to double";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::Double(is_null, value);
        }

      }
    }
  }
}

namespace NewsGate
{
  namespace Moderation
  {
    namespace Ad
    {
      namespace DB
      {
//
// GroupCondition class declaration
//
        class GroupCondition: public El::MySQL::Row
        {
        public:
          EL_EXCEPTION(Exception, El::MySQL::Exception);
          EL_EXCEPTION(IsNull, Exception);

        public:
          GroupCondition(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
            throw(Exception, El::Exception);

          El::MySQL::UnsignedLongLong id() const
           throw(Exception, El::Exception);

          El::MySQL::String name() const
           throw(Exception, El::Exception);

          El::MySQL::String status() const
           throw(Exception, El::Exception);

        };

//
// GroupCondition class definition
//
        inline
        GroupCondition::GroupCondition(El::MySQL::Result* result, unsigned long use_columns)
          throw(Exception, El::Exception)
            : Row(result)
        {
          unsigned long num_columns = std::min(use_columns, (unsigned long)3);

          if(result->num_fields() != num_columns)
          {
            std::ostringstream ostr;
            ostr << "GroupCondition::GroupCondition: unexpected number of fields "
                 << result->num_fields() << " instead of " << num_columns;

            throw Exception(ostr.str());
          }

          if(use_columns >= 0)
          {
            return;
          }

          enum_field_types type = (*result)[0].type;

          if(type != 8)
          {
            std::ostringstream ostr;
            ostr << "GroupCondition::GroupCondition: unexpected type " << type
                 << " instead of 8 for field id";

            throw Exception(ostr.str());
          }

          unsigned int flags = 
            (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "GroupCondition::GroupCondition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field id";

            throw Exception(ostr.str());
          }

          const char* name = (*result)[0].name;

          if(strcmp(name, "id"))
          {
            std::ostringstream ostr;
            ostr << "GroupCondition::GroupCondition: unexpected name " << name
                 << " instead of id for field id";

            throw Exception(ostr.str());
          }

          if(use_columns >= 1)
          {
            return;
          }

          type = (*result)[1].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "GroupCondition::GroupCondition: unexpected type " << type
                 << " instead of 253 for field name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "GroupCondition::GroupCondition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field name";

            throw Exception(ostr.str());
          }

          name = (*result)[1].name;

          if(strcmp(name, "name"))
          {
            std::ostringstream ostr;
            ostr << "GroupCondition::GroupCondition: unexpected name " << name
                 << " instead of name for field name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 2)
          {
            return;
          }

          type = (*result)[2].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "GroupCondition::GroupCondition: unexpected type " << type
                 << " instead of 254 for field status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "GroupCondition::GroupCondition: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field status";

            throw Exception(ostr.str());
          }

          name = (*result)[2].name;

          if(strcmp(name, "status"))
          {
            std::ostringstream ostr;
            ostr << "GroupCondition::GroupCondition: unexpected name " << name
                 << " instead of status for field status";

            throw Exception(ostr.str());
          }

        }

        inline
        El::MySQL::UnsignedLongLong
        GroupCondition::id() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("GroupCondition::id: row_ is 0");
          }

          if(0 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "GroupCondition::id: unexpected index 0 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long long value = 0;
          bool is_null = row_[0] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[0], lengths[0]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "GroupCondition::id: failed to convert 'id' field data"
                " to unsigned long long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLongLong(is_null, value);
        }

        inline
        El::MySQL::String
        GroupCondition::name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("GroupCondition::name: row_ is 0");
          }

          if(1 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "GroupCondition::name: unexpected index 1 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[1] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[1], lengths[1]);

          return tmp;
        }

        inline
        El::MySQL::String
        GroupCondition::status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("GroupCondition::status: row_ is 0");
          }

          if(2 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "GroupCondition::status: unexpected index 2 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[2] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[2], lengths[2]);

          return tmp;
        }

      }
    }
  }
}

namespace NewsGate
{
  namespace Moderation
  {
    namespace Ad
    {
      namespace DB
      {
//
// Placement class declaration
//
        class Placement: public El::MySQL::Row
        {
        public:
          EL_EXCEPTION(Exception, El::MySQL::Exception);
          EL_EXCEPTION(IsNull, Exception);

        public:
          Placement(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
            throw(Exception, El::Exception);

          El::MySQL::UnsignedLongLong id() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLongLong group_id() const
           throw(Exception, El::Exception);

          El::MySQL::String group_name() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLongLong campaign() const
           throw(Exception, El::Exception);

          El::MySQL::String campaign_name() const
           throw(Exception, El::Exception);

          El::MySQL::String name() const
           throw(Exception, El::Exception);

          El::MySQL::String status() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLongLong slot() const
           throw(Exception, El::Exception);

          El::MySQL::String slot_name() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong slot_min_width() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong slot_max_width() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong slot_min_height() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong slot_max_height() const
           throw(Exception, El::Exception);

          El::MySQL::String slot_status() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLongLong ad() const
           throw(Exception, El::Exception);

          El::MySQL::String ad_name() const
           throw(Exception, El::Exception);

          El::MySQL::String ad_status() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong ad_size() const
           throw(Exception, El::Exception);

          El::MySQL::String ad_size_name() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong ad_width() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong ad_height() const
           throw(Exception, El::Exception);

          El::MySQL::Double cpm() const
           throw(Exception, El::Exception);

          El::MySQL::String inject() const
           throw(Exception, El::Exception);

          El::MySQL::Double auction_factor() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong page_max_ad_num() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong page_id() const
           throw(Exception, El::Exception);

          El::MySQL::String page_name() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong adv_rst_max_ad_num() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong adv_max_ads_per_page() const
           throw(Exception, El::Exception);

          El::MySQL::String adv_status() const
           throw(Exception, El::Exception);

          El::MySQL::String adv_name() const
           throw(Exception, El::Exception);

          El::MySQL::String selector_status() const
           throw(Exception, El::Exception);

          El::MySQL::String group_status() const
           throw(Exception, El::Exception);

          El::MySQL::String size_status() const
           throw(Exception, El::Exception);

          El::MySQL::String page_status() const
           throw(Exception, El::Exception);

          El::MySQL::String campaign_status() const
           throw(Exception, El::Exception);

        };

//
// Placement class definition
//
        inline
        Placement::Placement(El::MySQL::Result* result, unsigned long use_columns)
          throw(Exception, El::Exception)
            : Row(result)
        {
          unsigned long num_columns = std::min(use_columns, (unsigned long)36);

          if(result->num_fields() != num_columns)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected number of fields "
                 << result->num_fields() << " instead of " << num_columns;

            throw Exception(ostr.str());
          }

          if(use_columns >= 0)
          {
            return;
          }

          enum_field_types type = (*result)[0].type;

          if(type != 8)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 8 for field id";

            throw Exception(ostr.str());
          }

          unsigned int flags = 
            (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field id";

            throw Exception(ostr.str());
          }

          const char* name = (*result)[0].name;

          if(strcmp(name, "id"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of id for field id";

            throw Exception(ostr.str());
          }

          if(use_columns >= 1)
          {
            return;
          }

          type = (*result)[1].type;

          if(type != 8)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 8 for field group_id";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field group_id";

            throw Exception(ostr.str());
          }

          name = (*result)[1].name;

          if(strcmp(name, "group_id"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of group_id for field group_id";

            throw Exception(ostr.str());
          }

          if(use_columns >= 2)
          {
            return;
          }

          type = (*result)[2].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 253 for field group_name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field group_name";

            throw Exception(ostr.str());
          }

          name = (*result)[2].name;

          if(strcmp(name, "group_name"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of group_name for field group_name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 3)
          {
            return;
          }

          type = (*result)[3].type;

          if(type != 8)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 8 for field campaign";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[3].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field campaign";

            throw Exception(ostr.str());
          }

          name = (*result)[3].name;

          if(strcmp(name, "campaign"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of campaign for field campaign";

            throw Exception(ostr.str());
          }

          if(use_columns >= 4)
          {
            return;
          }

          type = (*result)[4].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 253 for field campaign_name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[4].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field campaign_name";

            throw Exception(ostr.str());
          }

          name = (*result)[4].name;

          if(strcmp(name, "campaign_name"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of campaign_name for field campaign_name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 5)
          {
            return;
          }

          type = (*result)[5].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 253 for field name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[5].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field name";

            throw Exception(ostr.str());
          }

          name = (*result)[5].name;

          if(strcmp(name, "name"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of name for field name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 6)
          {
            return;
          }

          type = (*result)[6].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 254 for field status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[6].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field status";

            throw Exception(ostr.str());
          }

          name = (*result)[6].name;

          if(strcmp(name, "status"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of status for field status";

            throw Exception(ostr.str());
          }

          if(use_columns >= 7)
          {
            return;
          }

          type = (*result)[7].type;

          if(type != 8)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 8 for field slot";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[7].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field slot";

            throw Exception(ostr.str());
          }

          name = (*result)[7].name;

          if(strcmp(name, "slot"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of slot for field slot";

            throw Exception(ostr.str());
          }

          if(use_columns >= 8)
          {
            return;
          }

          type = (*result)[8].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 254 for field slot_name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[8].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field slot_name";

            throw Exception(ostr.str());
          }

          name = (*result)[8].name;

          if(strcmp(name, "slot_name"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of slot_name for field slot_name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 9)
          {
            return;
          }

          type = (*result)[9].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 3 for field slot_min_width";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[9].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field slot_min_width";

            throw Exception(ostr.str());
          }

          name = (*result)[9].name;

          if(strcmp(name, "slot_min_width"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of slot_min_width for field slot_min_width";

            throw Exception(ostr.str());
          }

          if(use_columns >= 10)
          {
            return;
          }

          type = (*result)[10].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 3 for field slot_max_width";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[10].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field slot_max_width";

            throw Exception(ostr.str());
          }

          name = (*result)[10].name;

          if(strcmp(name, "slot_max_width"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of slot_max_width for field slot_max_width";

            throw Exception(ostr.str());
          }

          if(use_columns >= 11)
          {
            return;
          }

          type = (*result)[11].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 3 for field slot_min_height";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[11].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field slot_min_height";

            throw Exception(ostr.str());
          }

          name = (*result)[11].name;

          if(strcmp(name, "slot_min_height"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of slot_min_height for field slot_min_height";

            throw Exception(ostr.str());
          }

          if(use_columns >= 12)
          {
            return;
          }

          type = (*result)[12].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 3 for field slot_max_height";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[12].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field slot_max_height";

            throw Exception(ostr.str());
          }

          name = (*result)[12].name;

          if(strcmp(name, "slot_max_height"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of slot_max_height for field slot_max_height";

            throw Exception(ostr.str());
          }

          if(use_columns >= 13)
          {
            return;
          }

          type = (*result)[13].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 254 for field slot_status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[13].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field slot_status";

            throw Exception(ostr.str());
          }

          name = (*result)[13].name;

          if(strcmp(name, "slot_status"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of slot_status for field slot_status";

            throw Exception(ostr.str());
          }

          if(use_columns >= 14)
          {
            return;
          }

          type = (*result)[14].type;

          if(type != 8)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 8 for field ad";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[14].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field ad";

            throw Exception(ostr.str());
          }

          name = (*result)[14].name;

          if(strcmp(name, "ad"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of ad for field ad";

            throw Exception(ostr.str());
          }

          if(use_columns >= 15)
          {
            return;
          }

          type = (*result)[15].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 253 for field ad_name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[15].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field ad_name";

            throw Exception(ostr.str());
          }

          name = (*result)[15].name;

          if(strcmp(name, "ad_name"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of ad_name for field ad_name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 16)
          {
            return;
          }

          type = (*result)[16].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 254 for field ad_status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[16].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field ad_status";

            throw Exception(ostr.str());
          }

          name = (*result)[16].name;

          if(strcmp(name, "ad_status"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of ad_status for field ad_status";

            throw Exception(ostr.str());
          }

          if(use_columns >= 17)
          {
            return;
          }

          type = (*result)[17].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 3 for field ad_size";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[17].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field ad_size";

            throw Exception(ostr.str());
          }

          name = (*result)[17].name;

          if(strcmp(name, "ad_size"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of ad_size for field ad_size";

            throw Exception(ostr.str());
          }

          if(use_columns >= 18)
          {
            return;
          }

          type = (*result)[18].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 254 for field ad_size_name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[18].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field ad_size_name";

            throw Exception(ostr.str());
          }

          name = (*result)[18].name;

          if(strcmp(name, "ad_size_name"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of ad_size_name for field ad_size_name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 19)
          {
            return;
          }

          type = (*result)[19].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 3 for field ad_width";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[19].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field ad_width";

            throw Exception(ostr.str());
          }

          name = (*result)[19].name;

          if(strcmp(name, "ad_width"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of ad_width for field ad_width";

            throw Exception(ostr.str());
          }

          if(use_columns >= 20)
          {
            return;
          }

          type = (*result)[20].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 3 for field ad_height";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[20].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field ad_height";

            throw Exception(ostr.str());
          }

          name = (*result)[20].name;

          if(strcmp(name, "ad_height"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of ad_height for field ad_height";

            throw Exception(ostr.str());
          }

          if(use_columns >= 21)
          {
            return;
          }

          type = (*result)[21].type;

          if(type != 5)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 5 for field cpm";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[21].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field cpm";

            throw Exception(ostr.str());
          }

          name = (*result)[21].name;

          if(strcmp(name, "cpm"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of cpm for field cpm";

            throw Exception(ostr.str());
          }

          if(use_columns >= 22)
          {
            return;
          }

          type = (*result)[22].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 254 for field inject";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[22].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field inject";

            throw Exception(ostr.str());
          }

          name = (*result)[22].name;

          if(strcmp(name, "inject"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of inject for field inject";

            throw Exception(ostr.str());
          }

          if(use_columns >= 23)
          {
            return;
          }

          type = (*result)[23].type;

          if(type != 5)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 5 for field auction_factor";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[23].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field auction_factor";

            throw Exception(ostr.str());
          }

          name = (*result)[23].name;

          if(strcmp(name, "auction_factor"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of auction_factor for field auction_factor";

            throw Exception(ostr.str());
          }

          if(use_columns >= 24)
          {
            return;
          }

          type = (*result)[24].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 3 for field page_max_ad_num";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[24].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field page_max_ad_num";

            throw Exception(ostr.str());
          }

          name = (*result)[24].name;

          if(strcmp(name, "page_max_ad_num"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of page_max_ad_num for field page_max_ad_num";

            throw Exception(ostr.str());
          }

          if(use_columns >= 25)
          {
            return;
          }

          type = (*result)[25].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 3 for field page_id";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[25].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field page_id";

            throw Exception(ostr.str());
          }

          name = (*result)[25].name;

          if(strcmp(name, "page_id"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of page_id for field page_id";

            throw Exception(ostr.str());
          }

          if(use_columns >= 26)
          {
            return;
          }

          type = (*result)[26].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 254 for field page_name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[26].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field page_name";

            throw Exception(ostr.str());
          }

          name = (*result)[26].name;

          if(strcmp(name, "page_name"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of page_name for field page_name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 27)
          {
            return;
          }

          type = (*result)[27].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 3 for field adv_rst_max_ad_num";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[27].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field adv_rst_max_ad_num";

            throw Exception(ostr.str());
          }

          name = (*result)[27].name;

          if(strcmp(name, "adv_rst_max_ad_num"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of adv_rst_max_ad_num for field adv_rst_max_ad_num";

            throw Exception(ostr.str());
          }

          if(use_columns >= 28)
          {
            return;
          }

          type = (*result)[28].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 3 for field adv_max_ads_per_page";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[28].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field adv_max_ads_per_page";

            throw Exception(ostr.str());
          }

          name = (*result)[28].name;

          if(strcmp(name, "adv_max_ads_per_page"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of adv_max_ads_per_page for field adv_max_ads_per_page";

            throw Exception(ostr.str());
          }

          if(use_columns >= 29)
          {
            return;
          }

          type = (*result)[29].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 254 for field adv_status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[29].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field adv_status";

            throw Exception(ostr.str());
          }

          name = (*result)[29].name;

          if(strcmp(name, "adv_status"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of adv_status for field adv_status";

            throw Exception(ostr.str());
          }

          if(use_columns >= 30)
          {
            return;
          }

          type = (*result)[30].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 254 for field adv_name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[30].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field adv_name";

            throw Exception(ostr.str());
          }

          name = (*result)[30].name;

          if(strcmp(name, "adv_name"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of adv_name for field adv_name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 31)
          {
            return;
          }

          type = (*result)[31].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 254 for field selector_status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[31].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field selector_status";

            throw Exception(ostr.str());
          }

          name = (*result)[31].name;

          if(strcmp(name, "selector_status"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of selector_status for field selector_status";

            throw Exception(ostr.str());
          }

          if(use_columns >= 32)
          {
            return;
          }

          type = (*result)[32].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 254 for field group_status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[32].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field group_status";

            throw Exception(ostr.str());
          }

          name = (*result)[32].name;

          if(strcmp(name, "group_status"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of group_status for field group_status";

            throw Exception(ostr.str());
          }

          if(use_columns >= 33)
          {
            return;
          }

          type = (*result)[33].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 254 for field size_status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[33].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field size_status";

            throw Exception(ostr.str());
          }

          name = (*result)[33].name;

          if(strcmp(name, "size_status"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of size_status for field size_status";

            throw Exception(ostr.str());
          }

          if(use_columns >= 34)
          {
            return;
          }

          type = (*result)[34].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 254 for field page_status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[34].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field page_status";

            throw Exception(ostr.str());
          }

          name = (*result)[34].name;

          if(strcmp(name, "page_status"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of page_status for field page_status";

            throw Exception(ostr.str());
          }

          if(use_columns >= 35)
          {
            return;
          }

          type = (*result)[35].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected type " << type
                 << " instead of 254 for field campaign_status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[35].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field campaign_status";

            throw Exception(ostr.str());
          }

          name = (*result)[35].name;

          if(strcmp(name, "campaign_status"))
          {
            std::ostringstream ostr;
            ostr << "Placement::Placement: unexpected name " << name
                 << " instead of campaign_status for field campaign_status";

            throw Exception(ostr.str());
          }

        }

        inline
        El::MySQL::UnsignedLongLong
        Placement::id() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::id: row_ is 0");
          }

          if(0 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::id: unexpected index 0 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long long value = 0;
          bool is_null = row_[0] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[0], lengths[0]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Placement::id: failed to convert 'id' field data"
                " to unsigned long long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLongLong(is_null, value);
        }

        inline
        El::MySQL::UnsignedLongLong
        Placement::group_id() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::group_id: row_ is 0");
          }

          if(1 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::group_id: unexpected index 1 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long long value = 0;
          bool is_null = row_[1] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[1], lengths[1]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Placement::group_id: failed to convert 'group_id' field data"
                " to unsigned long long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLongLong(is_null, value);
        }

        inline
        El::MySQL::String
        Placement::group_name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::group_name: row_ is 0");
          }

          if(2 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::group_name: unexpected index 2 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[2] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[2], lengths[2]);

          return tmp;
        }

        inline
        El::MySQL::UnsignedLongLong
        Placement::campaign() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::campaign: row_ is 0");
          }

          if(3 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::campaign: unexpected index 3 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long long value = 0;
          bool is_null = row_[3] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[3], lengths[3]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Placement::campaign: failed to convert 'campaign' field data"
                " to unsigned long long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLongLong(is_null, value);
        }

        inline
        El::MySQL::String
        Placement::campaign_name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::campaign_name: row_ is 0");
          }

          if(4 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::campaign_name: unexpected index 4 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[4] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[4], lengths[4]);

          return tmp;
        }

        inline
        El::MySQL::String
        Placement::name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::name: row_ is 0");
          }

          if(5 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::name: unexpected index 5 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[5] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[5], lengths[5]);

          return tmp;
        }

        inline
        El::MySQL::String
        Placement::status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::status: row_ is 0");
          }

          if(6 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::status: unexpected index 6 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[6] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[6], lengths[6]);

          return tmp;
        }

        inline
        El::MySQL::UnsignedLongLong
        Placement::slot() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::slot: row_ is 0");
          }

          if(7 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::slot: unexpected index 7 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long long value = 0;
          bool is_null = row_[7] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[7], lengths[7]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Placement::slot: failed to convert 'slot' field data"
                " to unsigned long long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLongLong(is_null, value);
        }

        inline
        El::MySQL::String
        Placement::slot_name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::slot_name: row_ is 0");
          }

          if(8 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::slot_name: unexpected index 8 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[8] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[8], lengths[8]);

          return tmp;
        }

        inline
        El::MySQL::UnsignedLong
        Placement::slot_min_width() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::slot_min_width: row_ is 0");
          }

          if(9 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::slot_min_width: unexpected index 9 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[9] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[9], lengths[9]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Placement::slot_min_width: failed to convert 'slot_min_width' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::UnsignedLong
        Placement::slot_max_width() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::slot_max_width: row_ is 0");
          }

          if(10 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::slot_max_width: unexpected index 10 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[10] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[10], lengths[10]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Placement::slot_max_width: failed to convert 'slot_max_width' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::UnsignedLong
        Placement::slot_min_height() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::slot_min_height: row_ is 0");
          }

          if(11 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::slot_min_height: unexpected index 11 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[11] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[11], lengths[11]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Placement::slot_min_height: failed to convert 'slot_min_height' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::UnsignedLong
        Placement::slot_max_height() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::slot_max_height: row_ is 0");
          }

          if(12 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::slot_max_height: unexpected index 12 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[12] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[12], lengths[12]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Placement::slot_max_height: failed to convert 'slot_max_height' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::String
        Placement::slot_status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::slot_status: row_ is 0");
          }

          if(13 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::slot_status: unexpected index 13 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[13] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[13], lengths[13]);

          return tmp;
        }

        inline
        El::MySQL::UnsignedLongLong
        Placement::ad() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::ad: row_ is 0");
          }

          if(14 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::ad: unexpected index 14 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long long value = 0;
          bool is_null = row_[14] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[14], lengths[14]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Placement::ad: failed to convert 'ad' field data"
                " to unsigned long long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLongLong(is_null, value);
        }

        inline
        El::MySQL::String
        Placement::ad_name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::ad_name: row_ is 0");
          }

          if(15 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::ad_name: unexpected index 15 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[15] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[15], lengths[15]);

          return tmp;
        }

        inline
        El::MySQL::String
        Placement::ad_status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::ad_status: row_ is 0");
          }

          if(16 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::ad_status: unexpected index 16 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[16] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[16], lengths[16]);

          return tmp;
        }

        inline
        El::MySQL::UnsignedLong
        Placement::ad_size() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::ad_size: row_ is 0");
          }

          if(17 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::ad_size: unexpected index 17 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[17] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[17], lengths[17]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Placement::ad_size: failed to convert 'ad_size' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::String
        Placement::ad_size_name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::ad_size_name: row_ is 0");
          }

          if(18 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::ad_size_name: unexpected index 18 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[18] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[18], lengths[18]);

          return tmp;
        }

        inline
        El::MySQL::UnsignedLong
        Placement::ad_width() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::ad_width: row_ is 0");
          }

          if(19 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::ad_width: unexpected index 19 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[19] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[19], lengths[19]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Placement::ad_width: failed to convert 'ad_width' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::UnsignedLong
        Placement::ad_height() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::ad_height: row_ is 0");
          }

          if(20 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::ad_height: unexpected index 20 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[20] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[20], lengths[20]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Placement::ad_height: failed to convert 'ad_height' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::Double
        Placement::cpm() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::cpm: row_ is 0");
          }

          if(21 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::cpm: unexpected index 21 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          double value = 0;
          bool is_null = row_[21] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[21], lengths[21]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Placement::cpm: failed to convert 'cpm' field data"
                " to double";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::Double(is_null, value);
        }

        inline
        El::MySQL::String
        Placement::inject() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::inject: row_ is 0");
          }

          if(22 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::inject: unexpected index 22 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[22] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[22], lengths[22]);

          return tmp;
        }

        inline
        El::MySQL::Double
        Placement::auction_factor() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::auction_factor: row_ is 0");
          }

          if(23 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::auction_factor: unexpected index 23 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          double value = 0;
          bool is_null = row_[23] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[23], lengths[23]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Placement::auction_factor: failed to convert 'auction_factor' field data"
                " to double";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::Double(is_null, value);
        }

        inline
        El::MySQL::UnsignedLong
        Placement::page_max_ad_num() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::page_max_ad_num: row_ is 0");
          }

          if(24 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::page_max_ad_num: unexpected index 24 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[24] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[24], lengths[24]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Placement::page_max_ad_num: failed to convert 'page_max_ad_num' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::UnsignedLong
        Placement::page_id() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::page_id: row_ is 0");
          }

          if(25 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::page_id: unexpected index 25 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[25] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[25], lengths[25]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Placement::page_id: failed to convert 'page_id' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::String
        Placement::page_name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::page_name: row_ is 0");
          }

          if(26 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::page_name: unexpected index 26 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[26] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[26], lengths[26]);

          return tmp;
        }

        inline
        El::MySQL::UnsignedLong
        Placement::adv_rst_max_ad_num() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::adv_rst_max_ad_num: row_ is 0");
          }

          if(27 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::adv_rst_max_ad_num: unexpected index 27 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[27] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[27], lengths[27]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Placement::adv_rst_max_ad_num: failed to convert 'adv_rst_max_ad_num' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::UnsignedLong
        Placement::adv_max_ads_per_page() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::adv_max_ads_per_page: row_ is 0");
          }

          if(28 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::adv_max_ads_per_page: unexpected index 28 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[28] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[28], lengths[28]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "Placement::adv_max_ads_per_page: failed to convert 'adv_max_ads_per_page' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

        inline
        El::MySQL::String
        Placement::adv_status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::adv_status: row_ is 0");
          }

          if(29 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::adv_status: unexpected index 29 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[29] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[29], lengths[29]);

          return tmp;
        }

        inline
        El::MySQL::String
        Placement::adv_name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::adv_name: row_ is 0");
          }

          if(30 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::adv_name: unexpected index 30 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[30] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[30], lengths[30]);

          return tmp;
        }

        inline
        El::MySQL::String
        Placement::selector_status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::selector_status: row_ is 0");
          }

          if(31 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::selector_status: unexpected index 31 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[31] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[31], lengths[31]);

          return tmp;
        }

        inline
        El::MySQL::String
        Placement::group_status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::group_status: row_ is 0");
          }

          if(32 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::group_status: unexpected index 32 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[32] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[32], lengths[32]);

          return tmp;
        }

        inline
        El::MySQL::String
        Placement::size_status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::size_status: row_ is 0");
          }

          if(33 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::size_status: unexpected index 33 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[33] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[33], lengths[33]);

          return tmp;
        }

        inline
        El::MySQL::String
        Placement::page_status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::page_status: row_ is 0");
          }

          if(34 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::page_status: unexpected index 34 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[34] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[34], lengths[34]);

          return tmp;
        }

        inline
        El::MySQL::String
        Placement::campaign_status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("Placement::campaign_status: row_ is 0");
          }

          if(35 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "Placement::campaign_status: unexpected index 35 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[35] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[35], lengths[35]);

          return tmp;
        }

      }
    }
  }
}

namespace NewsGate
{
  namespace Moderation
  {
    namespace Ad
    {
      namespace DB
      {
//
// CounterPlacement class declaration
//
        class CounterPlacement: public El::MySQL::Row
        {
        public:
          EL_EXCEPTION(Exception, El::MySQL::Exception);
          EL_EXCEPTION(IsNull, Exception);

        public:
          CounterPlacement(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
            throw(Exception, El::Exception);

          El::MySQL::UnsignedLongLong id() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLongLong group_id() const
           throw(Exception, El::Exception);

          El::MySQL::String group_name() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLongLong campaign() const
           throw(Exception, El::Exception);

          El::MySQL::String campaign_name() const
           throw(Exception, El::Exception);

          El::MySQL::String name() const
           throw(Exception, El::Exception);

          El::MySQL::String status() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLongLong page() const
           throw(Exception, El::Exception);

          El::MySQL::String page_name() const
           throw(Exception, El::Exception);

          El::MySQL::String page_status() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLongLong counter() const
           throw(Exception, El::Exception);

          El::MySQL::String counter_name() const
           throw(Exception, El::Exception);

          El::MySQL::String counter_status() const
           throw(Exception, El::Exception);

          El::MySQL::String adv_status() const
           throw(Exception, El::Exception);

          El::MySQL::String adv_name() const
           throw(Exception, El::Exception);

          El::MySQL::String selector_status() const
           throw(Exception, El::Exception);

          El::MySQL::String group_status() const
           throw(Exception, El::Exception);

          El::MySQL::String campaign_status() const
           throw(Exception, El::Exception);

        };

//
// CounterPlacement class definition
//
        inline
        CounterPlacement::CounterPlacement(El::MySQL::Result* result, unsigned long use_columns)
          throw(Exception, El::Exception)
            : Row(result)
        {
          unsigned long num_columns = std::min(use_columns, (unsigned long)18);

          if(result->num_fields() != num_columns)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected number of fields "
                 << result->num_fields() << " instead of " << num_columns;

            throw Exception(ostr.str());
          }

          if(use_columns >= 0)
          {
            return;
          }

          enum_field_types type = (*result)[0].type;

          if(type != 8)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
                 << " instead of 8 for field id";

            throw Exception(ostr.str());
          }

          unsigned int flags = 
            (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field id";

            throw Exception(ostr.str());
          }

          const char* name = (*result)[0].name;

          if(strcmp(name, "id"))
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
                 << " instead of id for field id";

            throw Exception(ostr.str());
          }

          if(use_columns >= 1)
          {
            return;
          }

          type = (*result)[1].type;

          if(type != 8)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
                 << " instead of 8 for field group_id";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field group_id";

            throw Exception(ostr.str());
          }

          name = (*result)[1].name;

          if(strcmp(name, "group_id"))
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
                 << " instead of group_id for field group_id";

            throw Exception(ostr.str());
          }

          if(use_columns >= 2)
          {
            return;
          }

          type = (*result)[2].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
                 << " instead of 253 for field group_name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field group_name";

            throw Exception(ostr.str());
          }

          name = (*result)[2].name;

          if(strcmp(name, "group_name"))
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
                 << " instead of group_name for field group_name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 3)
          {
            return;
          }

          type = (*result)[3].type;

          if(type != 8)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
                 << " instead of 8 for field campaign";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[3].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field campaign";

            throw Exception(ostr.str());
          }

          name = (*result)[3].name;

          if(strcmp(name, "campaign"))
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
                 << " instead of campaign for field campaign";

            throw Exception(ostr.str());
          }

          if(use_columns >= 4)
          {
            return;
          }

          type = (*result)[4].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
                 << " instead of 253 for field campaign_name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[4].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field campaign_name";

            throw Exception(ostr.str());
          }

          name = (*result)[4].name;

          if(strcmp(name, "campaign_name"))
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
                 << " instead of campaign_name for field campaign_name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 5)
          {
            return;
          }

          type = (*result)[5].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
                 << " instead of 253 for field name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[5].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field name";

            throw Exception(ostr.str());
          }

          name = (*result)[5].name;

          if(strcmp(name, "name"))
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
                 << " instead of name for field name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 6)
          {
            return;
          }

          type = (*result)[6].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
                 << " instead of 254 for field status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[6].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field status";

            throw Exception(ostr.str());
          }

          name = (*result)[6].name;

          if(strcmp(name, "status"))
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
                 << " instead of status for field status";

            throw Exception(ostr.str());
          }

          if(use_columns >= 7)
          {
            return;
          }

          type = (*result)[7].type;

          if(type != 8)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
                 << " instead of 8 for field page";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[7].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field page";

            throw Exception(ostr.str());
          }

          name = (*result)[7].name;

          if(strcmp(name, "page"))
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
                 << " instead of page for field page";

            throw Exception(ostr.str());
          }

          if(use_columns >= 8)
          {
            return;
          }

          type = (*result)[8].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
                 << " instead of 254 for field page_name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[8].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field page_name";

            throw Exception(ostr.str());
          }

          name = (*result)[8].name;

          if(strcmp(name, "page_name"))
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
                 << " instead of page_name for field page_name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 9)
          {
            return;
          }

          type = (*result)[9].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
                 << " instead of 254 for field page_status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[9].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field page_status";

            throw Exception(ostr.str());
          }

          name = (*result)[9].name;

          if(strcmp(name, "page_status"))
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
                 << " instead of page_status for field page_status";

            throw Exception(ostr.str());
          }

          if(use_columns >= 10)
          {
            return;
          }

          type = (*result)[10].type;

          if(type != 8)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
                 << " instead of 8 for field counter";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[10].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field counter";

            throw Exception(ostr.str());
          }

          name = (*result)[10].name;

          if(strcmp(name, "counter"))
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
                 << " instead of counter for field counter";

            throw Exception(ostr.str());
          }

          if(use_columns >= 11)
          {
            return;
          }

          type = (*result)[11].type;

          if(type != 253)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
                 << " instead of 253 for field counter_name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[11].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field counter_name";

            throw Exception(ostr.str());
          }

          name = (*result)[11].name;

          if(strcmp(name, "counter_name"))
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
                 << " instead of counter_name for field counter_name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 12)
          {
            return;
          }

          type = (*result)[12].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
                 << " instead of 254 for field counter_status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[12].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field counter_status";

            throw Exception(ostr.str());
          }

          name = (*result)[12].name;

          if(strcmp(name, "counter_status"))
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
                 << " instead of counter_status for field counter_status";

            throw Exception(ostr.str());
          }

          if(use_columns >= 13)
          {
            return;
          }

          type = (*result)[13].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
                 << " instead of 254 for field adv_status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[13].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field adv_status";

            throw Exception(ostr.str());
          }

          name = (*result)[13].name;

          if(strcmp(name, "adv_status"))
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
                 << " instead of adv_status for field adv_status";

            throw Exception(ostr.str());
          }

          if(use_columns >= 14)
          {
            return;
          }

          type = (*result)[14].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
                 << " instead of 254 for field adv_name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[14].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field adv_name";

            throw Exception(ostr.str());
          }

          name = (*result)[14].name;

          if(strcmp(name, "adv_name"))
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
                 << " instead of adv_name for field adv_name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 15)
          {
            return;
          }

          type = (*result)[15].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
                 << " instead of 254 for field selector_status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[15].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field selector_status";

            throw Exception(ostr.str());
          }

          name = (*result)[15].name;

          if(strcmp(name, "selector_status"))
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
                 << " instead of selector_status for field selector_status";

            throw Exception(ostr.str());
          }

          if(use_columns >= 16)
          {
            return;
          }

          type = (*result)[16].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
                 << " instead of 254 for field group_status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[16].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field group_status";

            throw Exception(ostr.str());
          }

          name = (*result)[16].name;

          if(strcmp(name, "group_status"))
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
                 << " instead of group_status for field group_status";

            throw Exception(ostr.str());
          }

          if(use_columns >= 17)
          {
            return;
          }

          type = (*result)[17].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
                 << " instead of 254 for field campaign_status";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[17].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field campaign_status";

            throw Exception(ostr.str());
          }

          name = (*result)[17].name;

          if(strcmp(name, "campaign_status"))
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
                 << " instead of campaign_status for field campaign_status";

            throw Exception(ostr.str());
          }

        }

        inline
        El::MySQL::UnsignedLongLong
        CounterPlacement::id() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("CounterPlacement::id: row_ is 0");
          }

          if(0 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::id: unexpected index 0 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long long value = 0;
          bool is_null = row_[0] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[0], lengths[0]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "CounterPlacement::id: failed to convert 'id' field data"
                " to unsigned long long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLongLong(is_null, value);
        }

        inline
        El::MySQL::UnsignedLongLong
        CounterPlacement::group_id() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("CounterPlacement::group_id: row_ is 0");
          }

          if(1 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::group_id: unexpected index 1 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long long value = 0;
          bool is_null = row_[1] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[1], lengths[1]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "CounterPlacement::group_id: failed to convert 'group_id' field data"
                " to unsigned long long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLongLong(is_null, value);
        }

        inline
        El::MySQL::String
        CounterPlacement::group_name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("CounterPlacement::group_name: row_ is 0");
          }

          if(2 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::group_name: unexpected index 2 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[2] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[2], lengths[2]);

          return tmp;
        }

        inline
        El::MySQL::UnsignedLongLong
        CounterPlacement::campaign() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("CounterPlacement::campaign: row_ is 0");
          }

          if(3 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::campaign: unexpected index 3 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long long value = 0;
          bool is_null = row_[3] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[3], lengths[3]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "CounterPlacement::campaign: failed to convert 'campaign' field data"
                " to unsigned long long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLongLong(is_null, value);
        }

        inline
        El::MySQL::String
        CounterPlacement::campaign_name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("CounterPlacement::campaign_name: row_ is 0");
          }

          if(4 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::campaign_name: unexpected index 4 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[4] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[4], lengths[4]);

          return tmp;
        }

        inline
        El::MySQL::String
        CounterPlacement::name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("CounterPlacement::name: row_ is 0");
          }

          if(5 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::name: unexpected index 5 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[5] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[5], lengths[5]);

          return tmp;
        }

        inline
        El::MySQL::String
        CounterPlacement::status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("CounterPlacement::status: row_ is 0");
          }

          if(6 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::status: unexpected index 6 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[6] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[6], lengths[6]);

          return tmp;
        }

        inline
        El::MySQL::UnsignedLongLong
        CounterPlacement::page() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("CounterPlacement::page: row_ is 0");
          }

          if(7 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::page: unexpected index 7 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long long value = 0;
          bool is_null = row_[7] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[7], lengths[7]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "CounterPlacement::page: failed to convert 'page' field data"
                " to unsigned long long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLongLong(is_null, value);
        }

        inline
        El::MySQL::String
        CounterPlacement::page_name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("CounterPlacement::page_name: row_ is 0");
          }

          if(8 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::page_name: unexpected index 8 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[8] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[8], lengths[8]);

          return tmp;
        }

        inline
        El::MySQL::String
        CounterPlacement::page_status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("CounterPlacement::page_status: row_ is 0");
          }

          if(9 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::page_status: unexpected index 9 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[9] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[9], lengths[9]);

          return tmp;
        }

        inline
        El::MySQL::UnsignedLongLong
        CounterPlacement::counter() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("CounterPlacement::counter: row_ is 0");
          }

          if(10 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::counter: unexpected index 10 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long long value = 0;
          bool is_null = row_[10] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[10], lengths[10]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "CounterPlacement::counter: failed to convert 'counter' field data"
                " to unsigned long long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLongLong(is_null, value);
        }

        inline
        El::MySQL::String
        CounterPlacement::counter_name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("CounterPlacement::counter_name: row_ is 0");
          }

          if(11 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::counter_name: unexpected index 11 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[11] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[11], lengths[11]);

          return tmp;
        }

        inline
        El::MySQL::String
        CounterPlacement::counter_status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("CounterPlacement::counter_status: row_ is 0");
          }

          if(12 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::counter_status: unexpected index 12 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[12] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[12], lengths[12]);

          return tmp;
        }

        inline
        El::MySQL::String
        CounterPlacement::adv_status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("CounterPlacement::adv_status: row_ is 0");
          }

          if(13 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::adv_status: unexpected index 13 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[13] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[13], lengths[13]);

          return tmp;
        }

        inline
        El::MySQL::String
        CounterPlacement::adv_name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("CounterPlacement::adv_name: row_ is 0");
          }

          if(14 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::adv_name: unexpected index 14 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[14] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[14], lengths[14]);

          return tmp;
        }

        inline
        El::MySQL::String
        CounterPlacement::selector_status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("CounterPlacement::selector_status: row_ is 0");
          }

          if(15 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::selector_status: unexpected index 15 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[15] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[15], lengths[15]);

          return tmp;
        }

        inline
        El::MySQL::String
        CounterPlacement::group_status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("CounterPlacement::group_status: row_ is 0");
          }

          if(16 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::group_status: unexpected index 16 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[16] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[16], lengths[16]);

          return tmp;
        }

        inline
        El::MySQL::String
        CounterPlacement::campaign_status() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("CounterPlacement::campaign_status: row_ is 0");
          }

          if(17 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::campaign_status: unexpected index 17 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[17] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[17], lengths[17]);

          return tmp;
        }

      }
    }
  }
}

namespace NewsGate
{
  namespace Moderation
  {
    namespace Ad
    {
      namespace DB
      {
//
// PageAdvAdvRestriction class declaration
//
        class PageAdvAdvRestriction: public El::MySQL::Row
        {
        public:
          EL_EXCEPTION(Exception, El::MySQL::Exception);
          EL_EXCEPTION(IsNull, Exception);

        public:
          PageAdvAdvRestriction(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
            throw(Exception, El::Exception);

          El::MySQL::UnsignedLongLong advertiser2() const
           throw(Exception, El::Exception);

          El::MySQL::String advertiser2_name() const
           throw(Exception, El::Exception);

          El::MySQL::UnsignedLong max_ad_num() const
           throw(Exception, El::Exception);

        };

//
// PageAdvAdvRestriction class definition
//
        inline
        PageAdvAdvRestriction::PageAdvAdvRestriction(El::MySQL::Result* result, unsigned long use_columns)
          throw(Exception, El::Exception)
            : Row(result)
        {
          unsigned long num_columns = std::min(use_columns, (unsigned long)3);

          if(result->num_fields() != num_columns)
          {
            std::ostringstream ostr;
            ostr << "PageAdvAdvRestriction::PageAdvAdvRestriction: unexpected number of fields "
                 << result->num_fields() << " instead of " << num_columns;

            throw Exception(ostr.str());
          }

          if(use_columns >= 0)
          {
            return;
          }

          enum_field_types type = (*result)[0].type;

          if(type != 8)
          {
            std::ostringstream ostr;
            ostr << "PageAdvAdvRestriction::PageAdvAdvRestriction: unexpected type " << type
                 << " instead of 8 for field advertiser2";

            throw Exception(ostr.str());
          }

          unsigned int flags = 
            (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "PageAdvAdvRestriction::PageAdvAdvRestriction: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field advertiser2";

            throw Exception(ostr.str());
          }

          const char* name = (*result)[0].name;

          if(strcmp(name, "advertiser2"))
          {
            std::ostringstream ostr;
            ostr << "PageAdvAdvRestriction::PageAdvAdvRestriction: unexpected name " << name
                 << " instead of advertiser2 for field advertiser2";

            throw Exception(ostr.str());
          }

          if(use_columns >= 1)
          {
            return;
          }

          type = (*result)[1].type;

          if(type != 254)
          {
            std::ostringstream ostr;
            ostr << "PageAdvAdvRestriction::PageAdvAdvRestriction: unexpected type " << type
                 << " instead of 254 for field advertiser2_name";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x1)
          {
            std::ostringstream ostr;
            ostr << "PageAdvAdvRestriction::PageAdvAdvRestriction: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x1 for field advertiser2_name";

            throw Exception(ostr.str());
          }

          name = (*result)[1].name;

          if(strcmp(name, "advertiser2_name"))
          {
            std::ostringstream ostr;
            ostr << "PageAdvAdvRestriction::PageAdvAdvRestriction: unexpected name " << name
                 << " instead of advertiser2_name for field advertiser2_name";

            throw Exception(ostr.str());
          }

          if(use_columns >= 2)
          {
            return;
          }

          type = (*result)[2].type;

          if(type != 3)
          {
            std::ostringstream ostr;
            ostr << "PageAdvAdvRestriction::PageAdvAdvRestriction: unexpected type " << type
                 << " instead of 3 for field max_ad_num";

            throw Exception(ostr.str());
          }

          flags = 
            (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

          if(flags != 0x21)
          {
            std::ostringstream ostr;
            ostr << "PageAdvAdvRestriction::PageAdvAdvRestriction: unexpected flags 0x" << std::hex
                 << flags << " instead of 0x21 for field max_ad_num";

            throw Exception(ostr.str());
          }

          name = (*result)[2].name;

          if(strcmp(name, "max_ad_num"))
          {
            std::ostringstream ostr;
            ostr << "PageAdvAdvRestriction::PageAdvAdvRestriction: unexpected name " << name
                 << " instead of max_ad_num for field max_ad_num";

            throw Exception(ostr.str());
          }

        }

        inline
        El::MySQL::UnsignedLongLong
        PageAdvAdvRestriction::advertiser2() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("PageAdvAdvRestriction::advertiser2: row_ is 0");
          }

          if(0 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "PageAdvAdvRestriction::advertiser2: unexpected index 0 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long long value = 0;
          bool is_null = row_[0] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[0], lengths[0]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "PageAdvAdvRestriction::advertiser2: failed to convert 'advertiser2' field data"
                " to unsigned long long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLongLong(is_null, value);
        }

        inline
        El::MySQL::String
        PageAdvAdvRestriction::advertiser2_name() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("PageAdvAdvRestriction::advertiser2_name: row_ is 0");
          }

          if(1 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "PageAdvAdvRestriction::advertiser2_name: unexpected index 1 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          if(row_[1] == 0)
          {
            El::MySQL::String tmp(true, 0, 0);
            return tmp;
          }

          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          El::MySQL::String tmp(false, row_[1], lengths[1]);

          return tmp;
        }

        inline
        El::MySQL::UnsignedLong
        PageAdvAdvRestriction::max_ad_num() const
          throw(Exception, El::Exception)
        {
          El::MySQL::DB::init_thread();

          if(row_ == 0)
          {
            throw Exception("PageAdvAdvRestriction::max_ad_num: row_ is 0");
          }

          if(2 >= result_->num_fields())
          {
            std::ostringstream ostr;
            ostr << "PageAdvAdvRestriction::max_ad_num: unexpected index 2 when number of fileds is "
                 << result_->num_fields();

            throw Exception(ostr.str());
          }

          unsigned long value = 0;
          bool is_null = row_[2] == 0;

          if(!is_null)
          {
            unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
            std::string tmp;
            tmp.assign(row_[2], lengths[2]);

            std::istringstream istr(tmp);
            istr >> value;

            if(istr.fail())
            {
              std::ostringstream ostr;
              ostr << "PageAdvAdvRestriction::max_ad_num: failed to convert 'max_ad_num' field data"
                " to unsigned long";

              throw Exception(ostr.str());
            }
          }

          return El::MySQL::UnsignedLong(is_null, value);
        }

      }
    }
  }
}

#endif // _NEWSGATE_MODERATION_AD_DB_GLOBAL__400539675_
